"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/casino/utils/rouletteUtils.ts":
/*!******************************************************!*\
  !*** ./src/components/casino/utils/rouletteUtils.ts ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateAgeMap: () => (/* binding */ calculateAgeMap),\n/* harmony export */   calculateGroupAge: () => (/* binding */ calculateGroupAge),\n/* harmony export */   findRepeats: () => (/* binding */ findRepeats),\n/* harmony export */   getContrastText: () => (/* binding */ getContrastText),\n/* harmony export */   getNumberColor: () => (/* binding */ getNumberColor),\n/* harmony export */   getProgressColor: () => (/* binding */ getProgressColor),\n/* harmony export */   getRepeatIndexes: () => (/* binding */ getRepeatIndexes)\n/* harmony export */ });\n/* harmony import */ var _constants_rouletteConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/rouletteConstants */ \"(app-pages-browser)/./src/components/casino/constants/rouletteConstants.ts\");\n\nfunction getContrastText(bgColor) {\n    // Удаляем # если есть\n    if (bgColor.startsWith('#')) bgColor = bgColor.slice(1);\n    // Преобразуем в rgb\n    let r = 0, g = 0, b = 0;\n    if (bgColor.length === 3) {\n        r = parseInt(bgColor[0] + bgColor[0], 16);\n        g = parseInt(bgColor[1] + bgColor[1], 16);\n        b = parseInt(bgColor[2] + bgColor[2], 16);\n    } else if (bgColor.length === 6) {\n        r = parseInt(bgColor.slice(0, 2), 16);\n        g = parseInt(bgColor.slice(2, 4), 16);\n        b = parseInt(bgColor.slice(4, 6), 16);\n    }\n    // Яркость по формуле WCAG\n    const brightness = (r * 299 + g * 587 + b * 114) / 1000;\n    return brightness > 140 ? '#222' : '#fff';\n}\nfunction getNumberColor(num) {\n    if (num === 0 || num === '00') return '#52b788'; // более бледный зеленый для 0 и 00\n    // Конвертируем в число для проверки\n    const numValue = typeof num === 'string' ? parseInt(num, 10) : num;\n    if (!isNaN(numValue) && _constants_rouletteConstants__WEBPACK_IMPORTED_MODULE_0__.RED_NUMBERS.has(numValue)) return '#e74c3c'; // красный\n    if (!isNaN(numValue) && _constants_rouletteConstants__WEBPACK_IMPORTED_MODULE_0__.BLACK_NUMBERS.has(numValue)) return '#2c3e50'; // черный\n    return '#52b788'; // зеленый для всех остальных (включая некорректные значения)\n}\nfunction calculateAgeMap(history) {\n    const DEBUG_LOGS = \"development\" === 'development';\n    if (DEBUG_LOGS) {\n        console.log(\"\\uD83D\\uDDFA️ Расчет AgeMap для \".concat(history.length, \" элементов истории\"));\n    }\n    // Инициализируем все числа максимальным возрастом\n    const ageMap = {};\n    for(let i = 0; i <= 36; i++){\n        ageMap[String(i)] = history.length;\n    }\n    ageMap['00'] = history.length;\n    // Проходим историю один раз с конца, обновляя только найденные числа\n    for(let i = history.length - 1; i >= 0; i--){\n        const num = String(history[i]);\n        if (ageMap[num] === history.length) {\n            ageMap[num] = history.length - 1 - i;\n        }\n    }\n    if (DEBUG_LOGS) {\n        console.log(\"✅ AgeMap готов (\".concat(Object.keys(ageMap).length, \" чисел)\"));\n    }\n    return ageMap;\n}\n// Кэш для цветов прогресса\nconst progressColorCache = new Map();\nfunction getProgressColor(count) {\n    // Проверяем кэш\n    if (progressColorCache.has(count)) {\n        return progressColorCache.get(count);\n    }\n    // Плавная градация от зеленого через желтый к оранжевому\n    // Нормализуем значение от 0 до 1 для диапазона 0-100\n    const normalizedCount = Math.min(count / 100, 1);\n    let color;\n    if (normalizedCount <= 0.2) {\n        // 0-20: Зеленый\n        color = '#22c55e';\n    } else if (normalizedCount <= 0.4) {\n        // 20-40: Зеленый → Светло-зеленый\n        const progress = (normalizedCount - 0.2) / 0.2;\n        color = interpolateColor('#22c55e', '#84cc16', progress);\n    } else if (normalizedCount <= 0.6) {\n        // 40-60: Светло-зеленый → Желто-зеленый\n        const progress = (normalizedCount - 0.4) / 0.2;\n        color = interpolateColor('#84cc16', '#eab308', progress);\n    } else if (normalizedCount <= 0.8) {\n        // 60-80: Желто-зеленый → Желтый\n        const progress = (normalizedCount - 0.6) / 0.2;\n        color = interpolateColor('#eab308', '#f59e0b', progress);\n    } else {\n        // 80-100: Желтый → Оранжевый\n        const progress = (normalizedCount - 0.8) / 0.2;\n        color = interpolateColor('#f59e0b', '#ea580c', progress);\n    }\n    // Кэшируем результат\n    progressColorCache.set(count, color);\n    return color;\n}\n// Функция для интерполяции между двумя цветами\nfunction interpolateColor(color1, color2, factor) {\n    // Преобразуем hex в RGB\n    const hex1 = color1.replace('#', '');\n    const hex2 = color2.replace('#', '');\n    const r1 = parseInt(hex1.substr(0, 2), 16);\n    const g1 = parseInt(hex1.substr(2, 2), 16);\n    const b1 = parseInt(hex1.substr(4, 2), 16);\n    const r2 = parseInt(hex2.substr(0, 2), 16);\n    const g2 = parseInt(hex2.substr(2, 2), 16);\n    const b2 = parseInt(hex2.substr(4, 2), 16);\n    // Интерполируем каждый канал\n    const r = Math.round(r1 + (r2 - r1) * factor);\n    const g = Math.round(g1 + (g2 - g1) * factor);\n    const b = Math.round(b1 + (b2 - b1) * factor);\n    // Преобразуем обратно в hex\n    return \"#\".concat(r.toString(16).padStart(2, '0')).concat(g.toString(16).padStart(2, '0')).concat(b.toString(16).padStart(2, '0'));\n}\n// Кэш для расчета возраста групп\nconst groupAgeCache = new Map();\nlet lastHistoryLength = 0;\nfunction calculateGroupAge(history, group) {\n    // Очищаем кэш если история изменилась\n    if (history.length !== lastHistoryLength) {\n        groupAgeCache.clear();\n        lastHistoryLength = history.length;\n    }\n    // Создаем уникальный ключ для группы\n    const groupKey = group.sort().join(',');\n    // Проверяем кэш\n    if (groupAgeCache.has(groupKey)) {\n        return groupAgeCache.get(groupKey);\n    }\n    let groupAge = history.length;\n    for(let i = history.length - 1; i >= 0; i--){\n        if (group.includes(history[i])) {\n            groupAge = history.length - 1 - i;\n            break;\n        }\n    }\n    // Кэшируем результат\n    groupAgeCache.set(groupKey, groupAge);\n    return groupAge;\n}\nfunction findRepeats(history) {\n    const repeats = [];\n    let i = 0;\n    while(i < history.length - 1){\n        let j = i;\n        while(j + 1 < history.length && history[j] === history[j + 1]){\n            j++;\n        }\n        if (j > i) {\n            repeats.push({\n                value: history[i],\n                start: i + 1,\n                length: j - i + 1\n            });\n            i = j + 1;\n        } else {\n            i++;\n        }\n    }\n    return repeats;\n}\nfunction getRepeatIndexes(history) {\n    const repeatIndexes = new Set();\n    let i = 0;\n    while(i < history.length - 1){\n        let j = i;\n        while(j + 1 < history.length && history[j] === history[j + 1]){\n            j++;\n        }\n        if (j > i) {\n            for(let k = i; k <= j; k++)repeatIndexes.add(k);\n            i = j + 1;\n        } else {\n            i++;\n        }\n    }\n    return repeatIndexes;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Nhc2luby91dGlscy9yb3VsZXR0ZVV0aWxzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTRFO0FBR3JFLFNBQVNFLGdCQUFnQkMsT0FBZTtJQUM3QyxzQkFBc0I7SUFDdEIsSUFBSUEsUUFBUUMsVUFBVSxDQUFDLE1BQU1ELFVBQVVBLFFBQVFFLEtBQUssQ0FBQztJQUNyRCxvQkFBb0I7SUFDcEIsSUFBSUMsSUFBSSxHQUFHQyxJQUFJLEdBQUdDLElBQUk7SUFDdEIsSUFBSUwsUUFBUU0sTUFBTSxLQUFLLEdBQUc7UUFDeEJILElBQUlJLFNBQVNQLE9BQU8sQ0FBQyxFQUFFLEdBQUdBLE9BQU8sQ0FBQyxFQUFFLEVBQUU7UUFDdENJLElBQUlHLFNBQVNQLE9BQU8sQ0FBQyxFQUFFLEdBQUdBLE9BQU8sQ0FBQyxFQUFFLEVBQUU7UUFDdENLLElBQUlFLFNBQVNQLE9BQU8sQ0FBQyxFQUFFLEdBQUdBLE9BQU8sQ0FBQyxFQUFFLEVBQUU7SUFDeEMsT0FBTyxJQUFJQSxRQUFRTSxNQUFNLEtBQUssR0FBRztRQUMvQkgsSUFBSUksU0FBU1AsUUFBUUUsS0FBSyxDQUFDLEdBQUcsSUFBSTtRQUNsQ0UsSUFBSUcsU0FBU1AsUUFBUUUsS0FBSyxDQUFDLEdBQUcsSUFBSTtRQUNsQ0csSUFBSUUsU0FBU1AsUUFBUUUsS0FBSyxDQUFDLEdBQUcsSUFBSTtJQUNwQztJQUNBLDBCQUEwQjtJQUMxQixNQUFNTSxhQUFhLENBQUNMLElBQUksTUFBTUMsSUFBSSxNQUFNQyxJQUFJLEdBQUUsSUFBSztJQUNuRCxPQUFPRyxhQUFhLE1BQU0sU0FBUztBQUNyQztBQUVPLFNBQVNDLGVBQWVDLEdBQW1CO0lBQ2hELElBQUlBLFFBQVEsS0FBS0EsUUFBUSxNQUFNLE9BQU8sV0FBVyxtQ0FBbUM7SUFFcEYsb0NBQW9DO0lBQ3BDLE1BQU1DLFdBQVcsT0FBT0QsUUFBUSxXQUFXSCxTQUFTRyxLQUFLLE1BQU1BO0lB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QUksSUFBSWxELFFBQVFULE1BQU0sSUFBSVMsT0FBTyxDQUFDa0QsRUFBRSxLQUFLbEQsT0FBTyxDQUFDa0QsSUFBSSxFQUFFLENBQUU7WUFDOURBO1FBQ0Y7UUFDQSxJQUFJQSxJQUFJNUMsR0FBRztZQUNULElBQUssSUFBSW1ELElBQUluRCxHQUFHbUQsS0FBS1AsR0FBR08sSUFBS0YsY0FBY0csR0FBRyxDQUFDRDtZQUMvQ25ELElBQUk0QyxJQUFJO1FBQ1YsT0FBTztZQUNMNUM7UUFDRjtJQUNGO0lBQ0EsT0FBT2lEO0FBQ1QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xccGxvdG5pa292YXlcXFdlYnN0b3JtUHJvamVjdHNcXGNhc2lub1xcc3JjXFxjb21wb25lbnRzXFxjYXNpbm9cXHV0aWxzXFxyb3VsZXR0ZVV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJFRF9OVU1CRVJTLCBCTEFDS19OVU1CRVJTIH0gZnJvbSAnLi4vY29uc3RhbnRzL3JvdWxldHRlQ29uc3RhbnRzJztcbmltcG9ydCB0eXBlIHsgUm91bGV0dGVOdW1iZXIsIFJlcGVhdFNlcmllcywgQWdlTWFwIH0gZnJvbSAnLi4vdHlwZXMvcm91bGV0dGVUeXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250cmFzdFRleHQoYmdDb2xvcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8g0KPQtNCw0LvRj9C10LwgIyDQtdGB0LvQuCDQtdGB0YLRjFxuICBpZiAoYmdDb2xvci5zdGFydHNXaXRoKCcjJykpIGJnQ29sb3IgPSBiZ0NvbG9yLnNsaWNlKDEpO1xuICAvLyDQn9GA0LXQvtCx0YDQsNC30YPQtdC8INCyIHJnYlxuICBsZXQgciA9IDAsIGcgPSAwLCBiID0gMDtcbiAgaWYgKGJnQ29sb3IubGVuZ3RoID09PSAzKSB7XG4gICAgciA9IHBhcnNlSW50KGJnQ29sb3JbMF0gKyBiZ0NvbG9yWzBdLCAxNik7XG4gICAgZyA9IHBhcnNlSW50KGJnQ29sb3JbMV0gKyBiZ0NvbG9yWzFdLCAxNik7XG4gICAgYiA9IHBhcnNlSW50KGJnQ29sb3JbMl0gKyBiZ0NvbG9yWzJdLCAxNik7XG4gIH0gZWxzZSBpZiAoYmdDb2xvci5sZW5ndGggPT09IDYpIHtcbiAgICByID0gcGFyc2VJbnQoYmdDb2xvci5zbGljZSgwLCAyKSwgMTYpO1xuICAgIGcgPSBwYXJzZUludChiZ0NvbG9yLnNsaWNlKDIsIDQpLCAxNik7XG4gICAgYiA9IHBhcnNlSW50KGJnQ29sb3Iuc2xpY2UoNCwgNiksIDE2KTtcbiAgfVxuICAvLyDQr9GA0LrQvtGB0YLRjCDQv9C+INGE0L7RgNC80YPQu9C1IFdDQUdcbiAgY29uc3QgYnJpZ2h0bmVzcyA9IChyICogMjk5ICsgZyAqIDU4NyArIGIgKiAxMTQpIC8gMTAwMDtcbiAgcmV0dXJuIGJyaWdodG5lc3MgPiAxNDAgPyAnIzIyMicgOiAnI2ZmZic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROdW1iZXJDb2xvcihudW06IFJvdWxldHRlTnVtYmVyKTogc3RyaW5nIHtcbiAgaWYgKG51bSA9PT0gMCB8fCBudW0gPT09ICcwMCcpIHJldHVybiAnIzUyYjc4OCc7IC8vINCx0L7Qu9C10LUg0LHQu9C10LTQvdGL0Lkg0LfQtdC70LXQvdGL0Lkg0LTQu9GPIDAg0LggMDBcbiAgXG4gIC8vINCa0L7QvdCy0LXRgNGC0LjRgNGD0LXQvCDQsiDRh9C40YHQu9C+INC00LvRjyDQv9GA0L7QstC10YDQutC4XG4gIGNvbnN0IG51bVZhbHVlID0gdHlwZW9mIG51bSA9PT0gJ3N0cmluZycgPyBwYXJzZUludChudW0sIDEwKSA6IG51bTtcbiAgXG4gIGlmICghaXNOYU4obnVtVmFsdWUpICYmIFJFRF9OVU1CRVJTLmhhcyhudW1WYWx1ZSkpIHJldHVybiAnI2U3NGMzYyc7IC8vINC60YDQsNGB0L3Ri9C5XG4gIGlmICghaXNOYU4obnVtVmFsdWUpICYmIEJMQUNLX05VTUJFUlMuaGFzKG51bVZhbHVlKSkgcmV0dXJuICcjMmMzZTUwJzsgLy8g0YfQtdGA0L3Ri9C5XG4gIFxuICByZXR1cm4gJyM1MmI3ODgnOyAvLyDQt9C10LvQtdC90YvQuSDQtNC70Y8g0LLRgdC10YUg0L7RgdGC0LDQu9GM0L3Ri9GFICjQstC60LvRjtGH0LDRjyDQvdC10LrQvtGA0YDQtdC60YLQvdGL0LUg0LfQvdCw0YfQtdC90LjRjylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUFnZU1hcChoaXN0b3J5OiBSb3VsZXR0ZU51bWJlcltdKTogQWdlTWFwIHtcbiAgY29uc3QgREVCVUdfTE9HUyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnO1xuICBcbiAgaWYgKERFQlVHX0xPR1MpIHtcbiAgICBjb25zb2xlLmxvZyhg8J+Xuu+4jyDQoNCw0YHRh9C10YIgQWdlTWFwINC00LvRjyAke2hpc3RvcnkubGVuZ3RofSDRjdC70LXQvNC10L3RgtC+0LIg0LjRgdGC0L7RgNC40LhgKTtcbiAgfVxuICBcbiAgLy8g0JjQvdC40YbQuNCw0LvQuNC30LjRgNGD0LXQvCDQstGB0LUg0YfQuNGB0LvQsCDQvNCw0LrRgdC40LzQsNC70YzQvdGL0Lwg0LLQvtC30YDQsNGB0YLQvtC8XG4gIGNvbnN0IGFnZU1hcDogQWdlTWFwID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IDM2OyBpKyspIHtcbiAgICBhZ2VNYXBbU3RyaW5nKGkpXSA9IGhpc3RvcnkubGVuZ3RoO1xuICB9XG4gIGFnZU1hcFsnMDAnXSA9IGhpc3RvcnkubGVuZ3RoO1xuICBcbiAgLy8g0J/RgNC+0YXQvtC00LjQvCDQuNGB0YLQvtGA0LjRjiDQvtC00LjQvSDRgNCw0Lcg0YEg0LrQvtC90YbQsCwg0L7QsdC90L7QstC70Y/RjyDRgtC+0LvRjNC60L4g0L3QsNC50LTQtdC90L3Ri9C1INGH0LjRgdC70LBcbiAgZm9yIChsZXQgaSA9IGhpc3RvcnkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBudW0gPSBTdHJpbmcoaGlzdG9yeVtpXSk7XG4gICAgaWYgKGFnZU1hcFtudW1dID09PSBoaXN0b3J5Lmxlbmd0aCkgeyAvLyDQldGB0LvQuCDQtdGJ0LUg0L3QtSDQvtCx0L3QvtCy0LvQtdC90L5cbiAgICAgIGFnZU1hcFtudW1dID0gaGlzdG9yeS5sZW5ndGggLSAxIC0gaTtcbiAgICB9XG4gIH1cbiAgXG4gIGlmIChERUJVR19MT0dTKSB7XG4gICAgY29uc29sZS5sb2coYOKchSBBZ2VNYXAg0LPQvtGC0L7QsiAoJHtPYmplY3Qua2V5cyhhZ2VNYXApLmxlbmd0aH0g0YfQuNGB0LXQuylgKTtcbiAgfVxuICByZXR1cm4gYWdlTWFwO1xufVxuXG4vLyDQmtGN0Ygg0LTQu9GPINGG0LLQtdGC0L7QsiDQv9GA0L7Qs9GA0LXRgdGB0LBcbmNvbnN0IHByb2dyZXNzQ29sb3JDYWNoZSA9IG5ldyBNYXA8bnVtYmVyLCBzdHJpbmc+KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9ncmVzc0NvbG9yKGNvdW50OiBudW1iZXIpOiBzdHJpbmcge1xuICAvLyDQn9GA0L7QstC10YDRj9C10Lwg0LrRjdGIXG4gIGlmIChwcm9ncmVzc0NvbG9yQ2FjaGUuaGFzKGNvdW50KSkge1xuICAgIHJldHVybiBwcm9ncmVzc0NvbG9yQ2FjaGUuZ2V0KGNvdW50KSE7XG4gIH1cbiAgXG4gIC8vINCf0LvQsNCy0L3QsNGPINCz0YDQsNC00LDRhtC40Y8g0L7RgiDQt9C10LvQtdC90L7Qs9C+INGH0LXRgNC10Lcg0LbQtdC70YLRi9C5INC6INC+0YDQsNC90LbQtdCy0L7QvNGDXG4gIC8vINCd0L7RgNC80LDQu9C40LfRg9C10Lwg0LfQvdCw0YfQtdC90LjQtSDQvtGCIDAg0LTQviAxINC00LvRjyDQtNC40LDQv9Cw0LfQvtC90LAgMC0xMDBcbiAgY29uc3Qgbm9ybWFsaXplZENvdW50ID0gTWF0aC5taW4oY291bnQgLyAxMDAsIDEpO1xuICBcbiAgbGV0IGNvbG9yOiBzdHJpbmc7XG4gIFxuICBpZiAobm9ybWFsaXplZENvdW50IDw9IDAuMikge1xuICAgIC8vIDAtMjA6INCX0LXQu9C10L3Ri9C5XG4gICAgY29sb3IgPSAnIzIyYzU1ZSc7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXplZENvdW50IDw9IDAuNCkge1xuICAgIC8vIDIwLTQwOiDQl9C10LvQtdC90YvQuSDihpIg0KHQstC10YLQu9C+LdC30LXQu9C10L3Ri9C5XG4gICAgY29uc3QgcHJvZ3Jlc3MgPSAobm9ybWFsaXplZENvdW50IC0gMC4yKSAvIDAuMjtcbiAgICBjb2xvciA9IGludGVycG9sYXRlQ29sb3IoJyMyMmM1NWUnLCAnIzg0Y2MxNicsIHByb2dyZXNzKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemVkQ291bnQgPD0gMC42KSB7XG4gICAgLy8gNDAtNjA6INCh0LLQtdGC0LvQvi3Qt9C10LvQtdC90YvQuSDihpIg0JbQtdC70YLQvi3Qt9C10LvQtdC90YvQuVxuICAgIGNvbnN0IHByb2dyZXNzID0gKG5vcm1hbGl6ZWRDb3VudCAtIDAuNCkgLyAwLjI7XG4gICAgY29sb3IgPSBpbnRlcnBvbGF0ZUNvbG9yKCcjODRjYzE2JywgJyNlYWIzMDgnLCBwcm9ncmVzcyk7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXplZENvdW50IDw9IDAuOCkge1xuICAgIC8vIDYwLTgwOiDQltC10LvRgtC+LdC30LXQu9C10L3Ri9C5IOKGkiDQltC10LvRgtGL0LlcbiAgICBjb25zdCBwcm9ncmVzcyA9IChub3JtYWxpemVkQ291bnQgLSAwLjYpIC8gMC4yO1xuICAgIGNvbG9yID0gaW50ZXJwb2xhdGVDb2xvcignI2VhYjMwOCcsICcjZjU5ZTBiJywgcHJvZ3Jlc3MpO1xuICB9IGVsc2Uge1xuICAgIC8vIDgwLTEwMDog0JbQtdC70YLRi9C5IOKGkiDQntGA0LDQvdC20LXQstGL0LlcbiAgICBjb25zdCBwcm9ncmVzcyA9IChub3JtYWxpemVkQ291bnQgLSAwLjgpIC8gMC4yO1xuICAgIGNvbG9yID0gaW50ZXJwb2xhdGVDb2xvcignI2Y1OWUwYicsICcjZWE1ODBjJywgcHJvZ3Jlc3MpO1xuICB9XG4gIFxuICAvLyDQmtGN0YjQuNGA0YPQtdC8INGA0LXQt9GD0LvRjNGC0LDRglxuICBwcm9ncmVzc0NvbG9yQ2FjaGUuc2V0KGNvdW50LCBjb2xvcik7XG4gIHJldHVybiBjb2xvcjtcbn1cblxuLy8g0KTRg9C90LrRhtC40Y8g0LTQu9GPINC40L3RgtC10YDQv9C+0LvRj9GG0LjQuCDQvNC10LbQtNGDINC00LLRg9C80Y8g0YbQstC10YLQsNC80LhcbmZ1bmN0aW9uIGludGVycG9sYXRlQ29sb3IoY29sb3IxOiBzdHJpbmcsIGNvbG9yMjogc3RyaW5nLCBmYWN0b3I6IG51bWJlcik6IHN0cmluZyB7XG4gIC8vINCf0YDQtdC+0LHRgNCw0LfRg9C10LwgaGV4INCyIFJHQlxuICBjb25zdCBoZXgxID0gY29sb3IxLnJlcGxhY2UoJyMnLCAnJyk7XG4gIGNvbnN0IGhleDIgPSBjb2xvcjIucmVwbGFjZSgnIycsICcnKTtcbiAgXG4gIGNvbnN0IHIxID0gcGFyc2VJbnQoaGV4MS5zdWJzdHIoMCwgMiksIDE2KTtcbiAgY29uc3QgZzEgPSBwYXJzZUludChoZXgxLnN1YnN0cigyLCAyKSwgMTYpO1xuICBjb25zdCBiMSA9IHBhcnNlSW50KGhleDEuc3Vic3RyKDQsIDIpLCAxNik7XG4gIFxuICBjb25zdCByMiA9IHBhcnNlSW50KGhleDIuc3Vic3RyKDAsIDIpLCAxNik7XG4gIGNvbnN0IGcyID0gcGFyc2VJbnQoaGV4Mi5zdWJzdHIoMiwgMiksIDE2KTtcbiAgY29uc3QgYjIgPSBwYXJzZUludChoZXgyLnN1YnN0cig0LCAyKSwgMTYpO1xuICBcbiAgLy8g0JjQvdGC0LXRgNC/0L7Qu9C40YDRg9C10Lwg0LrQsNC20LTRi9C5INC60LDQvdCw0LtcbiAgY29uc3QgciA9IE1hdGgucm91bmQocjEgKyAocjIgLSByMSkgKiBmYWN0b3IpO1xuICBjb25zdCBnID0gTWF0aC5yb3VuZChnMSArIChnMiAtIGcxKSAqIGZhY3Rvcik7XG4gIGNvbnN0IGIgPSBNYXRoLnJvdW5kKGIxICsgKGIyIC0gYjEpICogZmFjdG9yKTtcbiAgXG4gIC8vINCf0YDQtdC+0LHRgNCw0LfRg9C10Lwg0L7QsdGA0LDRgtC90L4g0LIgaGV4XG4gIHJldHVybiBgIyR7ci50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKX0ke2cudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyl9JHtiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpfWA7XG59XG5cbi8vINCa0Y3RiCDQtNC70Y8g0YDQsNGB0YfQtdGC0LAg0LLQvtC30YDQsNGB0YLQsCDQs9GA0YPQv9C/XG5jb25zdCBncm91cEFnZUNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcbmxldCBsYXN0SGlzdG9yeUxlbmd0aCA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVHcm91cEFnZShoaXN0b3J5OiBSb3VsZXR0ZU51bWJlcltdLCBncm91cDogbnVtYmVyW10pOiBudW1iZXIge1xuICAvLyDQntGH0LjRidCw0LXQvCDQutGN0Ygg0LXRgdC70Lgg0LjRgdGC0L7RgNC40Y8g0LjQt9C80LXQvdC40LvQsNGB0YxcbiAgaWYgKGhpc3RvcnkubGVuZ3RoICE9PSBsYXN0SGlzdG9yeUxlbmd0aCkge1xuICAgIGdyb3VwQWdlQ2FjaGUuY2xlYXIoKTtcbiAgICBsYXN0SGlzdG9yeUxlbmd0aCA9IGhpc3RvcnkubGVuZ3RoO1xuICB9XG4gIFxuICAvLyDQodC+0LfQtNCw0LXQvCDRg9C90LjQutCw0LvRjNC90YvQuSDQutC70Y7RhyDQtNC70Y8g0LPRgNGD0L/Qv9GLXG4gIGNvbnN0IGdyb3VwS2V5ID0gZ3JvdXAuc29ydCgpLmpvaW4oJywnKTtcbiAgXG4gIC8vINCf0YDQvtCy0LXRgNGP0LXQvCDQutGN0YhcbiAgaWYgKGdyb3VwQWdlQ2FjaGUuaGFzKGdyb3VwS2V5KSkge1xuICAgIHJldHVybiBncm91cEFnZUNhY2hlLmdldChncm91cEtleSkhO1xuICB9XG4gIFxuICBsZXQgZ3JvdXBBZ2UgPSBoaXN0b3J5Lmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IGhpc3RvcnkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoZ3JvdXAuaW5jbHVkZXMoaGlzdG9yeVtpXSBhcyBudW1iZXIpKSB7XG4gICAgICBncm91cEFnZSA9IGhpc3RvcnkubGVuZ3RoIC0gMSAtIGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgXG4gIC8vINCa0Y3RiNC40YDRg9C10Lwg0YDQtdC30YPQu9GM0YLQsNGCXG4gIGdyb3VwQWdlQ2FjaGUuc2V0KGdyb3VwS2V5LCBncm91cEFnZSk7XG4gIHJldHVybiBncm91cEFnZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRSZXBlYXRzKGhpc3Rvcnk6IFJvdWxldHRlTnVtYmVyW10pOiBSZXBlYXRTZXJpZXNbXSB7XG4gIGNvbnN0IHJlcGVhdHM6IFJlcGVhdFNlcmllc1tdID0gW107XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBoaXN0b3J5Lmxlbmd0aCAtIDEpIHtcbiAgICBsZXQgaiA9IGk7XG4gICAgd2hpbGUgKGogKyAxIDwgaGlzdG9yeS5sZW5ndGggJiYgaGlzdG9yeVtqXSA9PT0gaGlzdG9yeVtqICsgMV0pIHtcbiAgICAgIGorKztcbiAgICB9XG4gICAgaWYgKGogPiBpKSB7XG4gICAgICByZXBlYXRzLnB1c2goeyB2YWx1ZTogaGlzdG9yeVtpXSwgc3RhcnQ6IGkgKyAxLCBsZW5ndGg6IGogLSBpICsgMSB9KTtcbiAgICAgIGkgPSBqICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVwZWF0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlcGVhdEluZGV4ZXMoaGlzdG9yeTogUm91bGV0dGVOdW1iZXJbXSk6IFNldDxudW1iZXI+IHtcbiAgY29uc3QgcmVwZWF0SW5kZXhlcyA9IG5ldyBTZXQ8bnVtYmVyPigpO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgaGlzdG9yeS5sZW5ndGggLSAxKSB7XG4gICAgbGV0IGogPSBpO1xuICAgIHdoaWxlIChqICsgMSA8IGhpc3RvcnkubGVuZ3RoICYmIGhpc3Rvcnlbal0gPT09IGhpc3RvcnlbaiArIDFdKSB7XG4gICAgICBqKys7XG4gICAgfVxuICAgIGlmIChqID4gaSkge1xuICAgICAgZm9yIChsZXQgayA9IGk7IGsgPD0gajsgaysrKSByZXBlYXRJbmRleGVzLmFkZChrKTtcbiAgICAgIGkgPSBqICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVwZWF0SW5kZXhlcztcbn0gIl0sIm5hbWVzIjpbIlJFRF9OVU1CRVJTIiwiQkxBQ0tfTlVNQkVSUyIsImdldENvbnRyYXN0VGV4dCIsImJnQ29sb3IiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJyIiwiZyIsImIiLCJsZW5ndGgiLCJwYXJzZUludCIsImJyaWdodG5lc3MiLCJnZXROdW1iZXJDb2xvciIsIm51bSIsIm51bVZhbHVlIiwiaXNOYU4iLCJoYXMiLCJjYWxjdWxhdGVBZ2VNYXAiLCJoaXN0b3J5IiwiREVCVUdfTE9HUyIsInByb2Nlc3MiLCJjb25zb2xlIiwibG9nIiwiYWdlTWFwIiwiaSIsIlN0cmluZyIsIk9iamVjdCIsImtleXMiLCJwcm9ncmVzc0NvbG9yQ2FjaGUiLCJNYXAiLCJnZXRQcm9ncmVzc0NvbG9yIiwiY291bnQiLCJnZXQiLCJub3JtYWxpemVkQ291bnQiLCJNYXRoIiwibWluIiwiY29sb3IiLCJwcm9ncmVzcyIsImludGVycG9sYXRlQ29sb3IiLCJzZXQiLCJjb2xvcjEiLCJjb2xvcjIiLCJmYWN0b3IiLCJoZXgxIiwicmVwbGFjZSIsImhleDIiLCJyMSIsInN1YnN0ciIsImcxIiwiYjEiLCJyMiIsImcyIiwiYjIiLCJyb3VuZCIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJncm91cEFnZUNhY2hlIiwibGFzdEhpc3RvcnlMZW5ndGgiLCJjYWxjdWxhdGVHcm91cEFnZSIsImdyb3VwIiwiY2xlYXIiLCJncm91cEtleSIsInNvcnQiLCJqb2luIiwiZ3JvdXBBZ2UiLCJpbmNsdWRlcyIsImZpbmRSZXBlYXRzIiwicmVwZWF0cyIsImoiLCJwdXNoIiwidmFsdWUiLCJzdGFydCIsImdldFJlcGVhdEluZGV4ZXMiLCJyZXBlYXRJbmRleGVzIiwiU2V0IiwiayIsImFkZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/casino/utils/rouletteUtils.ts\n"));

/***/ })

});