"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/casino/utils/rouletteUtils.ts":
/*!******************************************************!*\
  !*** ./src/components/casino/utils/rouletteUtils.ts ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateAgeMap: () => (/* binding */ calculateAgeMap),\n/* harmony export */   calculateGroupAge: () => (/* binding */ calculateGroupAge),\n/* harmony export */   findRepeats: () => (/* binding */ findRepeats),\n/* harmony export */   getContrastText: () => (/* binding */ getContrastText),\n/* harmony export */   getNumberColor: () => (/* binding */ getNumberColor),\n/* harmony export */   getProgressColor: () => (/* binding */ getProgressColor),\n/* harmony export */   getRepeatIndexes: () => (/* binding */ getRepeatIndexes)\n/* harmony export */ });\n/* harmony import */ var _constants_rouletteConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/rouletteConstants */ \"(app-pages-browser)/./src/components/casino/constants/rouletteConstants.ts\");\n\nfunction getContrastText(bgColor) {\n    // –£–¥–∞–ª—è–µ–º # –µ—Å–ª–∏ –µ—Å—Ç—å\n    if (bgColor.startsWith('#')) bgColor = bgColor.slice(1);\n    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ rgb\n    let r = 0, g = 0, b = 0;\n    if (bgColor.length === 3) {\n        r = parseInt(bgColor[0] + bgColor[0], 16);\n        g = parseInt(bgColor[1] + bgColor[1], 16);\n        b = parseInt(bgColor[2] + bgColor[2], 16);\n    } else if (bgColor.length === 6) {\n        r = parseInt(bgColor.slice(0, 2), 16);\n        g = parseInt(bgColor.slice(2, 4), 16);\n        b = parseInt(bgColor.slice(4, 6), 16);\n    }\n    // –Ø—Ä–∫–æ—Å—Ç—å –ø–æ —Ñ–æ—Ä–º—É–ª–µ WCAG\n    const brightness = (r * 299 + g * 587 + b * 114) / 1000;\n    return brightness > 140 ? '#222' : '#fff';\n}\nfunction getNumberColor(num) {\n    if (num === 0 || num === '00') return '#2ecc71'; // –∑–µ–ª–µ–Ω—ã–π –¥–ª—è 0 –∏ 00\n    if (_constants_rouletteConstants__WEBPACK_IMPORTED_MODULE_0__.RED_NUMBERS.has(num)) return '#e74c3c';\n    if (_constants_rouletteConstants__WEBPACK_IMPORTED_MODULE_0__.BLACK_NUMBERS.has(num)) return '#2c3e50';\n    return '#bdc3c7';\n}\nfunction calculateAgeMap(history) {\n    console.time('calculateAgeMap');\n    console.log('üó∫Ô∏è –†–∞—Å—á–µ—Ç AgeMap, —Ä–∞–∑–º–µ—Ä –∏—Å—Ç–æ—Ä–∏–∏:', history.length);\n    const startTime = performance.now();\n    const ageMap = {};\n    const reversedHistory = [\n        ...history\n    ].reverse(); // –°–æ–∑–¥–∞–µ–º –æ–¥–∏–Ω —Ä–∞–∑\n    const reverseTime = performance.now();\n    console.log(\"\\uD83D\\uDD04 –†–µ–≤–µ—Ä—Å –∏—Å—Ç–æ—Ä–∏–∏: \".concat((reverseTime - startTime).toFixed(2), \"ms\"));\n    for(let i = 0; i <= 36; i++){\n        const index = reversedHistory.findIndex((v)=>v === i);\n        ageMap[String(i)] = index === -1 ? history.length : index;\n    }\n    const numbersTime = performance.now();\n    console.log(\"\\uD83D\\uDD22 –û–±—Ä–∞–±–æ—Ç–∫–∞ —á–∏—Å–µ–ª 0-36: \".concat((numbersTime - reverseTime).toFixed(2), \"ms\"));\n    ageMap['00'] = reversedHistory.findIndex((v)=>v === '00');\n    if (ageMap['00'] === -1) ageMap['00'] = history.length;\n    const endTime = performance.now();\n    console.log(\"‚úÖ calculateAgeMap –∑–∞–≤–µ—Ä—à–µ–Ω: \".concat((endTime - startTime).toFixed(2), \"ms\"));\n    console.timeEnd('calculateAgeMap');\n    return ageMap;\n}\n// –ö—ç—à –¥–ª—è —Ü–≤–µ—Ç–æ–≤ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞\nconst progressColorCache = new Map();\nfunction getProgressColor(count) {\n    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à\n    if (progressColorCache.has(count)) {\n        return progressColorCache.get(count);\n    }\n    // –ü–ª–∞–≤–Ω–∞—è –≥—Ä–∞–¥–∞—Ü–∏—è –æ—Ç –∑–µ–ª–µ–Ω–æ–≥–æ —á–µ—Ä–µ–∑ –∂–µ–ª—Ç—ã–π –∫ –æ—Ä–∞–Ω–∂–µ–≤–æ–º—É\n    // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –æ—Ç 0 –¥–æ 1 –¥–ª—è –¥–∏–∞–ø–∞–∑–æ–Ω–∞ 0-100\n    const normalizedCount = Math.min(count / 100, 1);\n    let color;\n    if (normalizedCount <= 0.2) {\n        // 0-20: –ó–µ–ª–µ–Ω—ã–π\n        color = '#22c55e';\n    } else if (normalizedCount <= 0.4) {\n        // 20-40: –ó–µ–ª–µ–Ω—ã–π ‚Üí –°–≤–µ—Ç–ª–æ-–∑–µ–ª–µ–Ω—ã–π\n        const progress = (normalizedCount - 0.2) / 0.2;\n        color = interpolateColor('#22c55e', '#84cc16', progress);\n    } else if (normalizedCount <= 0.6) {\n        // 40-60: –°–≤–µ—Ç–ª–æ-–∑–µ–ª–µ–Ω—ã–π ‚Üí –ñ–µ–ª—Ç–æ-–∑–µ–ª–µ–Ω—ã–π\n        const progress = (normalizedCount - 0.4) / 0.2;\n        color = interpolateColor('#84cc16', '#eab308', progress);\n    } else if (normalizedCount <= 0.8) {\n        // 60-80: –ñ–µ–ª—Ç–æ-–∑–µ–ª–µ–Ω—ã–π ‚Üí –ñ–µ–ª—Ç—ã–π\n        const progress = (normalizedCount - 0.6) / 0.2;\n        color = interpolateColor('#eab308', '#f59e0b', progress);\n    } else {\n        // 80-100: –ñ–µ–ª—Ç—ã–π ‚Üí –û—Ä–∞–Ω–∂–µ–≤—ã–π\n        const progress = (normalizedCount - 0.8) / 0.2;\n        color = interpolateColor('#f59e0b', '#ea580c', progress);\n    }\n    // –ö—ç—à–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç\n    progressColorCache.set(count, color);\n    return color;\n}\n// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–∏ –º–µ–∂–¥—É –¥–≤—É–º—è —Ü–≤–µ—Ç–∞–º–∏\nfunction interpolateColor(color1, color2, factor) {\n    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º hex –≤ RGB\n    const hex1 = color1.replace('#', '');\n    const hex2 = color2.replace('#', '');\n    const r1 = parseInt(hex1.substr(0, 2), 16);\n    const g1 = parseInt(hex1.substr(2, 2), 16);\n    const b1 = parseInt(hex1.substr(4, 2), 16);\n    const r2 = parseInt(hex2.substr(0, 2), 16);\n    const g2 = parseInt(hex2.substr(2, 2), 16);\n    const b2 = parseInt(hex2.substr(4, 2), 16);\n    // –ò–Ω—Ç–µ—Ä–ø–æ–ª–∏—Ä—É–µ–º –∫–∞–∂–¥—ã–π –∫–∞–Ω–∞–ª\n    const r = Math.round(r1 + (r2 - r1) * factor);\n    const g = Math.round(g1 + (g2 - g1) * factor);\n    const b = Math.round(b1 + (b2 - b1) * factor);\n    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –æ–±—Ä–∞—Ç–Ω–æ –≤ hex\n    return \"#\".concat(r.toString(16).padStart(2, '0')).concat(g.toString(16).padStart(2, '0')).concat(b.toString(16).padStart(2, '0'));\n}\nfunction calculateGroupAge(history, group) {\n    let groupAge = history.length;\n    for(let i = history.length - 1; i >= 0; i--){\n        if (group.includes(history[i])) {\n            groupAge = history.length - 1 - i;\n            break;\n        }\n    }\n    return groupAge;\n}\nfunction findRepeats(history) {\n    const repeats = [];\n    let i = 0;\n    while(i < history.length - 1){\n        let j = i;\n        while(j + 1 < history.length && history[j] === history[j + 1]){\n            j++;\n        }\n        if (j > i) {\n            repeats.push({\n                value: history[i],\n                start: i + 1,\n                length: j - i + 1\n            });\n            i = j + 1;\n        } else {\n            i++;\n        }\n    }\n    return repeats;\n}\nfunction getRepeatIndexes(history) {\n    const repeatIndexes = new Set();\n    let i = 0;\n    while(i < history.length - 1){\n        let j = i;\n        while(j + 1 < history.length && history[j] === history[j + 1]){\n            j++;\n        }\n        if (j > i) {\n            for(let k = i; k <= j; k++)repeatIndexes.add(k);\n            i = j + 1;\n        } else {\n            i++;\n        }\n    }\n    return repeatIndexes;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Nhc2luby91dGlscy9yb3VsZXR0ZVV0aWxzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTRFO0FBR3JFLFNBQVNFLGdCQUFnQkMsT0FBZTtJQUM3QyxzQkFBc0I7SUFDdEIsSUFBSUEsUUFBUUMsVUFBVSxDQUFDLE1BQU1ELFVBQVVBLFFBQVFFLEtBQUssQ0FBQztJQUNyRCxvQkFBb0I7SUFDcEIsSUFBSUMsSUFBSSxHQUFHQyxJQUFJLEdBQUdDLElBQUk7SUFDdEIsSUFBSUwsUUFBUU0sTUFBTSxLQUFLLEdBQUc7UUFDeEJILElBQUlJLFNBQVNQLE9BQU8sQ0FBQyxFQUFFLEdBQUdBLE9BQU8sQ0FBQyxFQUFFLEVBQUU7UUFDdENJLElBQUlHLFNBQVNQLE9BQU8sQ0FBQyxFQUFFLEdBQUdBLE9BQU8sQ0FBQyxFQUFFLEVBQUU7UUFDdENLLElBQUlFLFNBQVNQLE9BQU8sQ0FBQyxFQUFFLEdBQUdBLE9BQU8sQ0FBQyxFQUFFLEVBQUU7SUFDeEMsT0FBTyxJQUFJQSxRQUFRTSxNQUFNLEtBQUssR0FBRztRQUMvQkgsSUFBSUksU0FBU1AsUUFBUUUsS0FBSyxDQUFDLEdBQUcsSUFBSTtRQUNsQ0UsSUFBSUcsU0FBU1AsUUFBUUUsS0FBSyxDQUFDLEdBQUcsSUFBSTtRQUNsQ0csSUFBSUUsU0FBU1AsUUFBUUUsS0FBSyxDQUFDLEdBQUcsSUFBSTtJQUNwQztJQUNBLDBCQUEwQjtJQUMxQixNQUFNTSxhQUFhLENBQUNMLElBQUksTUFBTUMsSUFBSSxNQUFNQyxJQUFJLEdBQUUsSUFBSztJQUNuRCxPQUFPRyxhQUFhLE1BQU0sU0FBUztBQUNyQztBQUVPLFNBQVNDLGVBQWVDLEdBQW1CO0lBQ2hELElBQUlBLFFBQVEsS0FBS0EsUUFBUSxNQUFNLE9BQU8sV0FBVyxxQkFBcUI7SUFDdEUsSUFBSWIscUVBQVdBLENBQUNjLEdBQUcsQ0FBQ0QsTUFBZ0IsT0FBTztJQUMzQyxJQUFJWix1RUFBYUEs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InNvdXJjZXMiOlsiQzpcXFVzZXJzXFxwbG90bmlrb3ZheVxcV2Vic3Rvcm1Qcm9qZWN0c1xcY2FzaW5vXFxzcmNcXGNvbXBvbmVudHNcXGNhc2lub1xcdXRpbHNcXHJvdWxldHRlVXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUkVEX05VTUJFUlMsIEJMQUNLX05VTUJFUlMgfSBmcm9tICcuLi9jb25zdGFudHMvcm91bGV0dGVDb25zdGFudHMnO1xyXG5pbXBvcnQgdHlwZSB7IFJvdWxldHRlTnVtYmVyLCBSZXBlYXRTZXJpZXMsIEFnZU1hcCB9IGZyb20gJy4uL3R5cGVzL3JvdWxldHRlVHlwZXMnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRyYXN0VGV4dChiZ0NvbG9yOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIC8vINCj0LTQsNC70Y/QtdC8ICMg0LXRgdC70Lgg0LXRgdGC0YxcclxuICBpZiAoYmdDb2xvci5zdGFydHNXaXRoKCcjJykpIGJnQ29sb3IgPSBiZ0NvbG9yLnNsaWNlKDEpO1xyXG4gIC8vINCf0YDQtdC+0LHRgNCw0LfRg9C10Lwg0LIgcmdiXHJcbiAgbGV0IHIgPSAwLCBnID0gMCwgYiA9IDA7XHJcbiAgaWYgKGJnQ29sb3IubGVuZ3RoID09PSAzKSB7XHJcbiAgICByID0gcGFyc2VJbnQoYmdDb2xvclswXSArIGJnQ29sb3JbMF0sIDE2KTtcclxuICAgIGcgPSBwYXJzZUludChiZ0NvbG9yWzFdICsgYmdDb2xvclsxXSwgMTYpO1xyXG4gICAgYiA9IHBhcnNlSW50KGJnQ29sb3JbMl0gKyBiZ0NvbG9yWzJdLCAxNik7XHJcbiAgfSBlbHNlIGlmIChiZ0NvbG9yLmxlbmd0aCA9PT0gNikge1xyXG4gICAgciA9IHBhcnNlSW50KGJnQ29sb3Iuc2xpY2UoMCwgMiksIDE2KTtcclxuICAgIGcgPSBwYXJzZUludChiZ0NvbG9yLnNsaWNlKDIsIDQpLCAxNik7XHJcbiAgICBiID0gcGFyc2VJbnQoYmdDb2xvci5zbGljZSg0LCA2KSwgMTYpO1xyXG4gIH1cclxuICAvLyDQr9GA0LrQvtGB0YLRjCDQv9C+INGE0L7RgNC80YPQu9C1IFdDQUdcclxuICBjb25zdCBicmlnaHRuZXNzID0gKHIgKiAyOTkgKyBnICogNTg3ICsgYiAqIDExNCkgLyAxMDAwO1xyXG4gIHJldHVybiBicmlnaHRuZXNzID4gMTQwID8gJyMyMjInIDogJyNmZmYnO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TnVtYmVyQ29sb3IobnVtOiBSb3VsZXR0ZU51bWJlcik6IHN0cmluZyB7XHJcbiAgaWYgKG51bSA9PT0gMCB8fCBudW0gPT09ICcwMCcpIHJldHVybiAnIzJlY2M3MSc7IC8vINC30LXQu9C10L3Ri9C5INC00LvRjyAwINC4IDAwXHJcbiAgaWYgKFJFRF9OVU1CRVJTLmhhcyhudW0gYXMgbnVtYmVyKSkgcmV0dXJuICcjZTc0YzNjJztcclxuICBpZiAoQkxBQ0tfTlVNQkVSUy5oYXMobnVtIGFzIG51bWJlcikpIHJldHVybiAnIzJjM2U1MCc7XHJcbiAgcmV0dXJuICcjYmRjM2M3JztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUFnZU1hcChoaXN0b3J5OiBSb3VsZXR0ZU51bWJlcltdKTogQWdlTWFwIHtcclxuICBjb25zb2xlLnRpbWUoJ2NhbGN1bGF0ZUFnZU1hcCcpO1xyXG4gIGNvbnNvbGUubG9nKCfwn5e677iPINCg0LDRgdGH0LXRgiBBZ2VNYXAsINGA0LDQt9C80LXRgCDQuNGB0YLQvtGA0LjQuDonLCBoaXN0b3J5Lmxlbmd0aCk7XHJcbiAgXHJcbiAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgY29uc3QgYWdlTWFwOiBBZ2VNYXAgPSB7fTtcclxuICBjb25zdCByZXZlcnNlZEhpc3RvcnkgPSBbLi4uaGlzdG9yeV0ucmV2ZXJzZSgpOyAvLyDQodC+0LfQtNCw0LXQvCDQvtC00LjQvSDRgNCw0LdcclxuICBjb25zdCByZXZlcnNlVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gIGNvbnNvbGUubG9nKGDwn5SEINCg0LXQstC10YDRgSDQuNGB0YLQvtGA0LjQuDogJHsocmV2ZXJzZVRpbWUgLSBzdGFydFRpbWUpLnRvRml4ZWQoMil9bXNgKTtcclxuICBcclxuICBmb3IgKGxldCBpID0gMDsgaSA8PSAzNjsgaSsrKSB7XHJcbiAgICBjb25zdCBpbmRleCA9IHJldmVyc2VkSGlzdG9yeS5maW5kSW5kZXgoKHYpID0+IHYgPT09IGkpO1xyXG4gICAgYWdlTWFwW1N0cmluZyhpKV0gPSBpbmRleCA9PT0gLTEgPyBoaXN0b3J5Lmxlbmd0aCA6IGluZGV4O1xyXG4gIH1cclxuICBjb25zdCBudW1iZXJzVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gIGNvbnNvbGUubG9nKGDwn5SiINCe0LHRgNCw0LHQvtGC0LrQsCDRh9C40YHQtdC7IDAtMzY6ICR7KG51bWJlcnNUaW1lIC0gcmV2ZXJzZVRpbWUpLnRvRml4ZWQoMil9bXNgKTtcclxuICBcclxuICBhZ2VNYXBbJzAwJ10gPSByZXZlcnNlZEhpc3RvcnkuZmluZEluZGV4KCh2KSA9PiB2ID09PSAnMDAnKTtcclxuICBpZiAoYWdlTWFwWycwMCddID09PSAtMSkgYWdlTWFwWycwMCddID0gaGlzdG9yeS5sZW5ndGg7XHJcbiAgXHJcbiAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gIGNvbnNvbGUubG9nKGDinIUgY2FsY3VsYXRlQWdlTWFwINC30LDQstC10YDRiNC10L06ICR7KGVuZFRpbWUgLSBzdGFydFRpbWUpLnRvRml4ZWQoMil9bXNgKTtcclxuICBjb25zb2xlLnRpbWVFbmQoJ2NhbGN1bGF0ZUFnZU1hcCcpO1xyXG4gIFxyXG4gIHJldHVybiBhZ2VNYXA7XHJcbn1cclxuXHJcbi8vINCa0Y3RiCDQtNC70Y8g0YbQstC10YLQvtCyINC/0YDQvtCz0YDQtdGB0YHQsFxyXG5jb25zdCBwcm9ncmVzc0NvbG9yQ2FjaGUgPSBuZXcgTWFwPG51bWJlciwgc3RyaW5nPigpO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb2dyZXNzQ29sb3IoY291bnQ6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgLy8g0J/RgNC+0LLQtdGA0Y/QtdC8INC60Y3RiFxyXG4gIGlmIChwcm9ncmVzc0NvbG9yQ2FjaGUuaGFzKGNvdW50KSkge1xyXG4gICAgcmV0dXJuIHByb2dyZXNzQ29sb3JDYWNoZS5nZXQoY291bnQpITtcclxuICB9XHJcbiAgXHJcbiAgLy8g0J/Qu9Cw0LLQvdCw0Y8g0LPRgNCw0LTQsNGG0LjRjyDQvtGCINC30LXQu9C10L3QvtCz0L4g0YfQtdGA0LXQtyDQttC10LvRgtGL0Lkg0Log0L7RgNCw0L3QttC10LLQvtC80YNcclxuICAvLyDQndC+0YDQvNCw0LvQuNC30YPQtdC8INC30L3QsNGH0LXQvdC40LUg0L7RgiAwINC00L4gMSDQtNC70Y8g0LTQuNCw0L/QsNC30L7QvdCwIDAtMTAwXHJcbiAgY29uc3Qgbm9ybWFsaXplZENvdW50ID0gTWF0aC5taW4oY291bnQgLyAxMDAsIDEpO1xyXG4gIFxyXG4gIGxldCBjb2xvcjogc3RyaW5nO1xyXG4gIFxyXG4gIGlmIChub3JtYWxpemVkQ291bnQgPD0gMC4yKSB7XHJcbiAgICAvLyAwLTIwOiDQl9C10LvQtdC90YvQuVxyXG4gICAgY29sb3IgPSAnIzIyYzU1ZSc7XHJcbiAgfSBlbHNlIGlmIChub3JtYWxpemVkQ291bnQgPD0gMC40KSB7XHJcbiAgICAvLyAyMC00MDog0JfQtdC70LXQvdGL0Lkg4oaSINCh0LLQtdGC0LvQvi3Qt9C10LvQtdC90YvQuVxyXG4gICAgY29uc3QgcHJvZ3Jlc3MgPSAobm9ybWFsaXplZENvdW50IC0gMC4yKSAvIDAuMjtcclxuICAgIGNvbG9yID0gaW50ZXJwb2xhdGVDb2xvcignIzIyYzU1ZScsICcjODRjYzE2JywgcHJvZ3Jlc3MpO1xyXG4gIH0gZWxzZSBpZiAobm9ybWFsaXplZENvdW50IDw9IDAuNikge1xyXG4gICAgLy8gNDAtNjA6INCh0LLQtdGC0LvQvi3Qt9C10LvQtdC90YvQuSDihpIg0JbQtdC70YLQvi3Qt9C10LvQtdC90YvQuVxyXG4gICAgY29uc3QgcHJvZ3Jlc3MgPSAobm9ybWFsaXplZENvdW50IC0gMC40KSAvIDAuMjtcclxuICAgIGNvbG9yID0gaW50ZXJwb2xhdGVDb2xvcignIzg0Y2MxNicsICcjZWFiMzA4JywgcHJvZ3Jlc3MpO1xyXG4gIH0gZWxzZSBpZiAobm9ybWFsaXplZENvdW50IDw9IDAuOCkge1xyXG4gICAgLy8gNjAtODA6INCW0LXQu9GC0L4t0LfQtdC70LXQvdGL0Lkg4oaSINCW0LXQu9GC0YvQuVxyXG4gICAgY29uc3QgcHJvZ3Jlc3MgPSAobm9ybWFsaXplZENvdW50IC0gMC42KSAvIDAuMjtcclxuICAgIGNvbG9yID0gaW50ZXJwb2xhdGVDb2xvcignI2VhYjMwOCcsICcjZjU5ZTBiJywgcHJvZ3Jlc3MpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyA4MC0xMDA6INCW0LXQu9GC0YvQuSDihpIg0J7RgNCw0L3QttC10LLRi9C5XHJcbiAgICBjb25zdCBwcm9ncmVzcyA9IChub3JtYWxpemVkQ291bnQgLSAwLjgpIC8gMC4yO1xyXG4gICAgY29sb3IgPSBpbnRlcnBvbGF0ZUNvbG9yKCcjZjU5ZTBiJywgJyNlYTU4MGMnLCBwcm9ncmVzcyk7XHJcbiAgfVxyXG4gIFxyXG4gIC8vINCa0Y3RiNC40YDRg9C10Lwg0YDQtdC30YPQu9GM0YLQsNGCXHJcbiAgcHJvZ3Jlc3NDb2xvckNhY2hlLnNldChjb3VudCwgY29sb3IpO1xyXG4gIHJldHVybiBjb2xvcjtcclxufVxyXG5cclxuLy8g0KTRg9C90LrRhtC40Y8g0LTQu9GPINC40L3RgtC10YDQv9C+0LvRj9GG0LjQuCDQvNC10LbQtNGDINC00LLRg9C80Y8g0YbQstC10YLQsNC80LhcclxuZnVuY3Rpb24gaW50ZXJwb2xhdGVDb2xvcihjb2xvcjE6IHN0cmluZywgY29sb3IyOiBzdHJpbmcsIGZhY3RvcjogbnVtYmVyKTogc3RyaW5nIHtcclxuICAvLyDQn9GA0LXQvtCx0YDQsNC30YPQtdC8IGhleCDQsiBSR0JcclxuICBjb25zdCBoZXgxID0gY29sb3IxLnJlcGxhY2UoJyMnLCAnJyk7XHJcbiAgY29uc3QgaGV4MiA9IGNvbG9yMi5yZXBsYWNlKCcjJywgJycpO1xyXG4gIFxyXG4gIGNvbnN0IHIxID0gcGFyc2VJbnQoaGV4MS5zdWJzdHIoMCwgMiksIDE2KTtcclxuICBjb25zdCBnMSA9IHBhcnNlSW50KGhleDEuc3Vic3RyKDIsIDIpLCAxNik7XHJcbiAgY29uc3QgYjEgPSBwYXJzZUludChoZXgxLnN1YnN0cig0LCAyKSwgMTYpO1xyXG4gIFxyXG4gIGNvbnN0IHIyID0gcGFyc2VJbnQoaGV4Mi5zdWJzdHIoMCwgMiksIDE2KTtcclxuICBjb25zdCBnMiA9IHBhcnNlSW50KGhleDIuc3Vic3RyKDIsIDIpLCAxNik7XHJcbiAgY29uc3QgYjIgPSBwYXJzZUludChoZXgyLnN1YnN0cig0LCAyKSwgMTYpO1xyXG4gIFxyXG4gIC8vINCY0L3RgtC10YDQv9C+0LvQuNGA0YPQtdC8INC60LDQttC00YvQuSDQutCw0L3QsNC7XHJcbiAgY29uc3QgciA9IE1hdGgucm91bmQocjEgKyAocjIgLSByMSkgKiBmYWN0b3IpO1xyXG4gIGNvbnN0IGcgPSBNYXRoLnJvdW5kKGcxICsgKGcyIC0gZzEpICogZmFjdG9yKTtcclxuICBjb25zdCBiID0gTWF0aC5yb3VuZChiMSArIChiMiAtIGIxKSAqIGZhY3Rvcik7XHJcbiAgXHJcbiAgLy8g0J/RgNC10L7QsdGA0LDQt9GD0LXQvCDQvtCx0YDQsNGC0L3QviDQsiBoZXhcclxuICByZXR1cm4gYCMke3IudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyl9JHtnLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpfSR7Yi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKX1gO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlR3JvdXBBZ2UoaGlzdG9yeTogUm91bGV0dGVOdW1iZXJbXSwgZ3JvdXA6IG51bWJlcltdKTogbnVtYmVyIHtcclxuICBsZXQgZ3JvdXBBZ2UgPSBoaXN0b3J5Lmxlbmd0aDtcclxuICBmb3IgKGxldCBpID0gaGlzdG9yeS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgaWYgKGdyb3VwLmluY2x1ZGVzKGhpc3RvcnlbaV0gYXMgbnVtYmVyKSkge1xyXG4gICAgICBncm91cEFnZSA9IGhpc3RvcnkubGVuZ3RoIC0gMSAtIGk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZ3JvdXBBZ2U7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kUmVwZWF0cyhoaXN0b3J5OiBSb3VsZXR0ZU51bWJlcltdKTogUmVwZWF0U2VyaWVzW10ge1xyXG4gIGNvbnN0IHJlcGVhdHM6IFJlcGVhdFNlcmllc1tdID0gW107XHJcbiAgbGV0IGkgPSAwO1xyXG4gIHdoaWxlIChpIDwgaGlzdG9yeS5sZW5ndGggLSAxKSB7XHJcbiAgICBsZXQgaiA9IGk7XHJcbiAgICB3aGlsZSAoaiArIDEgPCBoaXN0b3J5Lmxlbmd0aCAmJiBoaXN0b3J5W2pdID09PSBoaXN0b3J5W2ogKyAxXSkge1xyXG4gICAgICBqKys7XHJcbiAgICB9XHJcbiAgICBpZiAoaiA+IGkpIHtcclxuICAgICAgcmVwZWF0cy5wdXNoKHsgdmFsdWU6IGhpc3RvcnlbaV0sIHN0YXJ0OiBpICsgMSwgbGVuZ3RoOiBqIC0gaSArIDEgfSk7XHJcbiAgICAgIGkgPSBqICsgMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGkrKztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlcGVhdHM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRSZXBlYXRJbmRleGVzKGhpc3Rvcnk6IFJvdWxldHRlTnVtYmVyW10pOiBTZXQ8bnVtYmVyPiB7XHJcbiAgY29uc3QgcmVwZWF0SW5kZXhlcyA9IG5ldyBTZXQ8bnVtYmVyPigpO1xyXG4gIGxldCBpID0gMDtcclxuICB3aGlsZSAoaSA8IGhpc3RvcnkubGVuZ3RoIC0gMSkge1xyXG4gICAgbGV0IGogPSBpO1xyXG4gICAgd2hpbGUgKGogKyAxIDwgaGlzdG9yeS5sZW5ndGggJiYgaGlzdG9yeVtqXSA9PT0gaGlzdG9yeVtqICsgMV0pIHtcclxuICAgICAgaisrO1xyXG4gICAgfVxyXG4gICAgaWYgKGogPiBpKSB7XHJcbiAgICAgIGZvciAobGV0IGsgPSBpOyBrIDw9IGo7IGsrKykgcmVwZWF0SW5kZXhlcy5hZGQoayk7XHJcbiAgICAgIGkgPSBqICsgMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGkrKztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlcGVhdEluZGV4ZXM7XHJcbn0gIl0sIm5hbWVzIjpbIlJFRF9OVU1CRVJTIiwiQkxBQ0tfTlVNQkVSUyIsImdldENvbnRyYXN0VGV4dCIsImJnQ29sb3IiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJyIiwiZyIsImIiLCJsZW5ndGgiLCJwYXJzZUludCIsImJyaWdodG5lc3MiLCJnZXROdW1iZXJDb2xvciIsIm51bSIsImhhcyIsImNhbGN1bGF0ZUFnZU1hcCIsImhpc3RvcnkiLCJjb25zb2xlIiwidGltZSIsImxvZyIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiYWdlTWFwIiwicmV2ZXJzZWRIaXN0b3J5IiwicmV2ZXJzZSIsInJldmVyc2VUaW1lIiwidG9GaXhlZCIsImkiLCJpbmRleCIsImZpbmRJbmRleCIsInYiLCJTdHJpbmciLCJudW1iZXJzVGltZSIsImVuZFRpbWUiLCJ0aW1lRW5kIiwicHJvZ3Jlc3NDb2xvckNhY2hlIiwiTWFwIiwiZ2V0UHJvZ3Jlc3NDb2xvciIsImNvdW50IiwiZ2V0Iiwibm9ybWFsaXplZENvdW50IiwiTWF0aCIsIm1pbiIsImNvbG9yIiwicHJvZ3Jlc3MiLCJpbnRlcnBvbGF0ZUNvbG9yIiwic2V0IiwiY29sb3IxIiwiY29sb3IyIiwiZmFjdG9yIiwiaGV4MSIsInJlcGxhY2UiLCJoZXgyIiwicjEiLCJzdWJzdHIiLCJnMSIsImIxIiwicjIiLCJnMiIsImIyIiwicm91bmQiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiY2FsY3VsYXRlR3JvdXBBZ2UiLCJncm91cCIsImdyb3VwQWdlIiwiaW5jbHVkZXMiLCJmaW5kUmVwZWF0cyIsInJlcGVhdHMiLCJqIiwicHVzaCIsInZhbHVlIiwic3RhcnQiLCJnZXRSZXBlYXRJbmRleGVzIiwicmVwZWF0SW5kZXhlcyIsIlNldCIsImsiLCJhZGQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/casino/utils/rouletteUtils.ts\n"));

/***/ })

});