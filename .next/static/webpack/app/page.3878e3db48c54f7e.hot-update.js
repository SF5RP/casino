"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/casino/utils/rouletteUtils.ts":
/*!******************************************************!*\
  !*** ./src/components/casino/utils/rouletteUtils.ts ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateAgeMap: () => (/* binding */ calculateAgeMap),\n/* harmony export */   calculateGroupAge: () => (/* binding */ calculateGroupAge),\n/* harmony export */   findRepeats: () => (/* binding */ findRepeats),\n/* harmony export */   getContrastText: () => (/* binding */ getContrastText),\n/* harmony export */   getNumberColor: () => (/* binding */ getNumberColor),\n/* harmony export */   getProgressColor: () => (/* binding */ getProgressColor),\n/* harmony export */   getRepeatIndexes: () => (/* binding */ getRepeatIndexes)\n/* harmony export */ });\n/* harmony import */ var _constants_rouletteConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/rouletteConstants */ \"(app-pages-browser)/./src/components/casino/constants/rouletteConstants.ts\");\n\nfunction getContrastText(bgColor) {\n    // Удаляем # если есть\n    if (bgColor.startsWith('#')) bgColor = bgColor.slice(1);\n    // Преобразуем в rgb\n    let r = 0, g = 0, b = 0;\n    if (bgColor.length === 3) {\n        r = parseInt(bgColor[0] + bgColor[0], 16);\n        g = parseInt(bgColor[1] + bgColor[1], 16);\n        b = parseInt(bgColor[2] + bgColor[2], 16);\n    } else if (bgColor.length === 6) {\n        r = parseInt(bgColor.slice(0, 2), 16);\n        g = parseInt(bgColor.slice(2, 4), 16);\n        b = parseInt(bgColor.slice(4, 6), 16);\n    }\n    // Яркость по формуле WCAG\n    const brightness = (r * 299 + g * 587 + b * 114) / 1000;\n    return brightness > 140 ? '#222' : '#fff';\n}\nfunction getNumberColor(num) {\n    if (num === 0 || num === '00') return '#52b788'; // более бледный зеленый для 0 и 00\n    if (_constants_rouletteConstants__WEBPACK_IMPORTED_MODULE_0__.RED_NUMBERS.has(num)) return '#e74c3c'; // красный как был\n    if (_constants_rouletteConstants__WEBPACK_IMPORTED_MODULE_0__.BLACK_NUMBERS.has(num)) return '#2c3e50'; // черный как был\n    return '#bdc3c7'; // серый как был\n}\nfunction calculateAgeMap(history) {\n    const DEBUG_LOGS = \"development\" === 'development';\n    if (DEBUG_LOGS) {\n        console.log(\"\\uD83D\\uDDFA️ Расчет AgeMap для \".concat(history.length, \" элементов истории\"));\n    }\n    // Инициализируем все числа максимальным возрастом\n    const ageMap = {};\n    for(let i = 0; i <= 36; i++){\n        ageMap[String(i)] = history.length;\n    }\n    ageMap['00'] = history.length;\n    // Проходим историю один раз с конца, обновляя только найденные числа\n    for(let i = history.length - 1; i >= 0; i--){\n        const num = String(history[i]);\n        if (ageMap[num] === history.length) {\n            ageMap[num] = history.length - 1 - i;\n        }\n    }\n    if (DEBUG_LOGS) {\n        console.log(\"✅ AgeMap готов (\".concat(Object.keys(ageMap).length, \" чисел)\"));\n    }\n    return ageMap;\n}\n// Кэш для цветов прогресса\nconst progressColorCache = new Map();\nfunction getProgressColor(count) {\n    // Проверяем кэш\n    if (progressColorCache.has(count)) {\n        return progressColorCache.get(count);\n    }\n    // Плавная градация от зеленого через желтый к оранжевому\n    // Нормализуем значение от 0 до 1 для диапазона 0-100\n    const normalizedCount = Math.min(count / 100, 1);\n    let color;\n    if (normalizedCount <= 0.2) {\n        // 0-20: Зеленый\n        color = '#22c55e';\n    } else if (normalizedCount <= 0.4) {\n        // 20-40: Зеленый → Светло-зеленый\n        const progress = (normalizedCount - 0.2) / 0.2;\n        color = interpolateColor('#22c55e', '#84cc16', progress);\n    } else if (normalizedCount <= 0.6) {\n        // 40-60: Светло-зеленый → Желто-зеленый\n        const progress = (normalizedCount - 0.4) / 0.2;\n        color = interpolateColor('#84cc16', '#eab308', progress);\n    } else if (normalizedCount <= 0.8) {\n        // 60-80: Желто-зеленый → Желтый\n        const progress = (normalizedCount - 0.6) / 0.2;\n        color = interpolateColor('#eab308', '#f59e0b', progress);\n    } else {\n        // 80-100: Желтый → Оранжевый\n        const progress = (normalizedCount - 0.8) / 0.2;\n        color = interpolateColor('#f59e0b', '#ea580c', progress);\n    }\n    // Кэшируем результат\n    progressColorCache.set(count, color);\n    return color;\n}\n// Функция для интерполяции между двумя цветами\nfunction interpolateColor(color1, color2, factor) {\n    // Преобразуем hex в RGB\n    const hex1 = color1.replace('#', '');\n    const hex2 = color2.replace('#', '');\n    const r1 = parseInt(hex1.substr(0, 2), 16);\n    const g1 = parseInt(hex1.substr(2, 2), 16);\n    const b1 = parseInt(hex1.substr(4, 2), 16);\n    const r2 = parseInt(hex2.substr(0, 2), 16);\n    const g2 = parseInt(hex2.substr(2, 2), 16);\n    const b2 = parseInt(hex2.substr(4, 2), 16);\n    // Интерполируем каждый канал\n    const r = Math.round(r1 + (r2 - r1) * factor);\n    const g = Math.round(g1 + (g2 - g1) * factor);\n    const b = Math.round(b1 + (b2 - b1) * factor);\n    // Преобразуем обратно в hex\n    return \"#\".concat(r.toString(16).padStart(2, '0')).concat(g.toString(16).padStart(2, '0')).concat(b.toString(16).padStart(2, '0'));\n}\n// Кэш для расчета возраста групп\nconst groupAgeCache = new Map();\nlet lastHistoryLength = 0;\nfunction calculateGroupAge(history, group) {\n    // Очищаем кэш если история изменилась\n    if (history.length !== lastHistoryLength) {\n        groupAgeCache.clear();\n        lastHistoryLength = history.length;\n    }\n    // Создаем уникальный ключ для группы\n    const groupKey = group.sort().join(',');\n    // Проверяем кэш\n    if (groupAgeCache.has(groupKey)) {\n        return groupAgeCache.get(groupKey);\n    }\n    let groupAge = history.length;\n    for(let i = history.length - 1; i >= 0; i--){\n        if (group.includes(history[i])) {\n            groupAge = history.length - 1 - i;\n            break;\n        }\n    }\n    // Кэшируем результат\n    groupAgeCache.set(groupKey, groupAge);\n    return groupAge;\n}\nfunction findRepeats(history) {\n    const repeats = [];\n    let i = 0;\n    while(i < history.length - 1){\n        let j = i;\n        while(j + 1 < history.length && history[j] === history[j + 1]){\n            j++;\n        }\n        if (j > i) {\n            repeats.push({\n                value: history[i],\n                start: i + 1,\n                length: j - i + 1\n            });\n            i = j + 1;\n        } else {\n            i++;\n        }\n    }\n    return repeats;\n}\nfunction getRepeatIndexes(history) {\n    const repeatIndexes = new Set();\n    let i = 0;\n    while(i < history.length - 1){\n        let j = i;\n        while(j + 1 < history.length && history[j] === history[j + 1]){\n            j++;\n        }\n        if (j > i) {\n            for(let k = i; k <= j; k++)repeatIndexes.add(k);\n            i = j + 1;\n        } else {\n            i++;\n        }\n    }\n    return repeatIndexes;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Nhc2luby91dGlscy9yb3VsZXR0ZVV0aWxzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTRFO0FBR3JFLFNBQVNFLGdCQUFnQkMsT0FBZTtJQUM3QyxzQkFBc0I7SUFDdEIsSUFBSUEsUUFBUUMsVUFBVSxDQUFDLE1BQU1ELFVBQVVBLFFBQVFFLEtBQUssQ0FBQztJQUNyRCxvQkFBb0I7SUFDcEIsSUFBSUMsSUFBSSxHQUFHQyxJQUFJLEdBQUdDLElBQUk7SUFDdEIsSUFBSUwsUUFBUU0sTUFBTSxLQUFLLEdBQUc7UUFDeEJILElBQUlJLFNBQVNQLE9BQU8sQ0FBQyxFQUFFLEdBQUdBLE9BQU8sQ0FBQyxFQUFFLEVBQUU7UUFDdENJLElBQUlHLFNBQVNQLE9BQU8sQ0FBQyxFQUFFLEdBQUdBLE9BQU8sQ0FBQyxFQUFFLEVBQUU7UUFDdENLLElBQUlFLFNBQVNQLE9BQU8sQ0FBQyxFQUFFLEdBQUdBLE9BQU8sQ0FBQyxFQUFFLEVBQUU7SUFDeEMsT0FBTyxJQUFJQSxRQUFRTSxNQUFNLEtBQUssR0FBRztRQUMvQkgsSUFBSUksU0FBU1AsUUFBUUUsS0FBSyxDQUFDLEdBQUcsSUFBSTtRQUNsQ0UsSUFBSUcsU0FBU1AsUUFBUUUsS0FBSyxDQUFDLEdBQUcsSUFBSTtRQUNsQ0csSUFBSUUsU0FBU1AsUUFBUUUsS0FBSyxDQUFDLEdBQUcsSUFBSTtJQUNwQztJQUNBLDBCQUEwQjtJQUMxQixNQUFNTSxhQUFhLENBQUNMLElBQUksTUFBTUMsSUFBSSxNQUFNQyxJQUFJLEdBQUUsSUFBSztJQUNuRCxPQUFPRyxhQUFhLE1BQU0sU0FBUztBQUNyQztBQUVPLFNBQVNDLGVBQWVDLEdBQW1CO0lBQ2hELElBQUlBLFFBQVEsS0FBS0EsUUFBUSxNQUFNLE9BQU8sV0FBVyxtQ0FBbUM7SUFDcEYsSUFBSWIscUVBQVdBLENBQUNjLEdBQUcsQ0FBQ0QsTUFBZ0IsT0FBTyxXQUFXLGtCQUFrQjtJQUN4RSxJ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QSxJQUFJQSxJQUFJNUMsR0FBRztZQUNULElBQUssSUFBSW1ELElBQUluRCxHQUFHbUQsS0FBS1AsR0FBR08sSUFBS0YsY0FBY0csR0FBRyxDQUFDRDtZQUMvQ25ELElBQUk0QyxJQUFJO1FBQ1YsT0FBTztZQUNMNUM7UUFDRjtJQUNGO0lBQ0EsT0FBT2lEO0FBQ1QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xccGxvdG5pa292YXlcXFdlYnN0b3JtUHJvamVjdHNcXGNhc2lub1xcc3JjXFxjb21wb25lbnRzXFxjYXNpbm9cXHV0aWxzXFxyb3VsZXR0ZVV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJFRF9OVU1CRVJTLCBCTEFDS19OVU1CRVJTIH0gZnJvbSAnLi4vY29uc3RhbnRzL3JvdWxldHRlQ29uc3RhbnRzJztcbmltcG9ydCB0eXBlIHsgUm91bGV0dGVOdW1iZXIsIFJlcGVhdFNlcmllcywgQWdlTWFwIH0gZnJvbSAnLi4vdHlwZXMvcm91bGV0dGVUeXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250cmFzdFRleHQoYmdDb2xvcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8g0KPQtNCw0LvRj9C10LwgIyDQtdGB0LvQuCDQtdGB0YLRjFxuICBpZiAoYmdDb2xvci5zdGFydHNXaXRoKCcjJykpIGJnQ29sb3IgPSBiZ0NvbG9yLnNsaWNlKDEpO1xuICAvLyDQn9GA0LXQvtCx0YDQsNC30YPQtdC8INCyIHJnYlxuICBsZXQgciA9IDAsIGcgPSAwLCBiID0gMDtcbiAgaWYgKGJnQ29sb3IubGVuZ3RoID09PSAzKSB7XG4gICAgciA9IHBhcnNlSW50KGJnQ29sb3JbMF0gKyBiZ0NvbG9yWzBdLCAxNik7XG4gICAgZyA9IHBhcnNlSW50KGJnQ29sb3JbMV0gKyBiZ0NvbG9yWzFdLCAxNik7XG4gICAgYiA9IHBhcnNlSW50KGJnQ29sb3JbMl0gKyBiZ0NvbG9yWzJdLCAxNik7XG4gIH0gZWxzZSBpZiAoYmdDb2xvci5sZW5ndGggPT09IDYpIHtcbiAgICByID0gcGFyc2VJbnQoYmdDb2xvci5zbGljZSgwLCAyKSwgMTYpO1xuICAgIGcgPSBwYXJzZUludChiZ0NvbG9yLnNsaWNlKDIsIDQpLCAxNik7XG4gICAgYiA9IHBhcnNlSW50KGJnQ29sb3Iuc2xpY2UoNCwgNiksIDE2KTtcbiAgfVxuICAvLyDQr9GA0LrQvtGB0YLRjCDQv9C+INGE0L7RgNC80YPQu9C1IFdDQUdcbiAgY29uc3QgYnJpZ2h0bmVzcyA9IChyICogMjk5ICsgZyAqIDU4NyArIGIgKiAxMTQpIC8gMTAwMDtcbiAgcmV0dXJuIGJyaWdodG5lc3MgPiAxNDAgPyAnIzIyMicgOiAnI2ZmZic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROdW1iZXJDb2xvcihudW06IFJvdWxldHRlTnVtYmVyKTogc3RyaW5nIHtcbiAgaWYgKG51bSA9PT0gMCB8fCBudW0gPT09ICcwMCcpIHJldHVybiAnIzUyYjc4OCc7IC8vINCx0L7Qu9C10LUg0LHQu9C10LTQvdGL0Lkg0LfQtdC70LXQvdGL0Lkg0LTQu9GPIDAg0LggMDBcbiAgaWYgKFJFRF9OVU1CRVJTLmhhcyhudW0gYXMgbnVtYmVyKSkgcmV0dXJuICcjZTc0YzNjJzsgLy8g0LrRgNCw0YHQvdGL0Lkg0LrQsNC6INCx0YvQu1xuICBpZiAoQkxBQ0tfTlVNQkVSUy5oYXMobnVtIGFzIG51bWJlcikpIHJldHVybiAnIzJjM2U1MCc7IC8vINGH0LXRgNC90YvQuSDQutCw0Log0LHRi9C7XG4gIHJldHVybiAnI2JkYzNjNyc7IC8vINGB0LXRgNGL0Lkg0LrQsNC6INCx0YvQu1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQWdlTWFwKGhpc3Rvcnk6IFJvdWxldHRlTnVtYmVyW10pOiBBZ2VNYXAge1xuICBjb25zdCBERUJVR19MT0dTID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCc7XG4gIFxuICBpZiAoREVCVUdfTE9HUykge1xuICAgIGNvbnNvbGUubG9nKGDwn5e677iPINCg0LDRgdGH0LXRgiBBZ2VNYXAg0LTQu9GPICR7aGlzdG9yeS5sZW5ndGh9INGN0LvQtdC80LXQvdGC0L7QsiDQuNGB0YLQvtGA0LjQuGApO1xuICB9XG4gIFxuICAvLyDQmNC90LjRhtC40LDQu9C40LfQuNGA0YPQtdC8INCy0YHQtSDRh9C40YHQu9CwINC80LDQutGB0LjQvNCw0LvRjNC90YvQvCDQstC+0LfRgNCw0YHRgtC+0LxcbiAgY29uc3QgYWdlTWFwOiBBZ2VNYXAgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMzY7IGkrKykge1xuICAgIGFnZU1hcFtTdHJpbmcoaSldID0gaGlzdG9yeS5sZW5ndGg7XG4gIH1cbiAgYWdlTWFwWycwMCddID0gaGlzdG9yeS5sZW5ndGg7XG4gIFxuICAvLyDQn9GA0L7RhdC+0LTQuNC8INC40YHRgtC+0YDQuNGOINC+0LTQuNC9INGA0LDQtyDRgSDQutC+0L3RhtCwLCDQvtCx0L3QvtCy0LvRj9GPINGC0L7Qu9GM0LrQviDQvdCw0LnQtNC10L3QvdGL0LUg0YfQuNGB0LvQsFxuICBmb3IgKGxldCBpID0gaGlzdG9yeS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IG51bSA9IFN0cmluZyhoaXN0b3J5W2ldKTtcbiAgICBpZiAoYWdlTWFwW251bV0gPT09IGhpc3RvcnkubGVuZ3RoKSB7IC8vINCV0YHQu9C4INC10YnQtSDQvdC1INC+0LHQvdC+0LLQu9C10L3QvlxuICAgICAgYWdlTWFwW251bV0gPSBoaXN0b3J5Lmxlbmd0aCAtIDEgLSBpO1xuICAgIH1cbiAgfVxuICBcbiAgaWYgKERFQlVHX0xPR1MpIHtcbiAgICBjb25zb2xlLmxvZyhg4pyFIEFnZU1hcCDQs9C+0YLQvtCyICgke09iamVjdC5rZXlzKGFnZU1hcCkubGVuZ3RofSDRh9C40YHQtdC7KWApO1xuICB9XG4gIHJldHVybiBhZ2VNYXA7XG59XG5cbi8vINCa0Y3RiCDQtNC70Y8g0YbQstC10YLQvtCyINC/0YDQvtCz0YDQtdGB0YHQsFxuY29uc3QgcHJvZ3Jlc3NDb2xvckNhY2hlID0gbmV3IE1hcDxudW1iZXIsIHN0cmluZz4oKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb2dyZXNzQ29sb3IoY291bnQ6IG51bWJlcik6IHN0cmluZyB7XG4gIC8vINCf0YDQvtCy0LXRgNGP0LXQvCDQutGN0YhcbiAgaWYgKHByb2dyZXNzQ29sb3JDYWNoZS5oYXMoY291bnQpKSB7XG4gICAgcmV0dXJuIHByb2dyZXNzQ29sb3JDYWNoZS5nZXQoY291bnQpITtcbiAgfVxuICBcbiAgLy8g0J/Qu9Cw0LLQvdCw0Y8g0LPRgNCw0LTQsNGG0LjRjyDQvtGCINC30LXQu9C10L3QvtCz0L4g0YfQtdGA0LXQtyDQttC10LvRgtGL0Lkg0Log0L7RgNCw0L3QttC10LLQvtC80YNcbiAgLy8g0J3QvtGA0LzQsNC70LjQt9GD0LXQvCDQt9C90LDRh9C10L3QuNC1INC+0YIgMCDQtNC+IDEg0LTQu9GPINC00LjQsNC/0LDQt9C+0L3QsCAwLTEwMFxuICBjb25zdCBub3JtYWxpemVkQ291bnQgPSBNYXRoLm1pbihjb3VudCAvIDEwMCwgMSk7XG4gIFxuICBsZXQgY29sb3I6IHN0cmluZztcbiAgXG4gIGlmIChub3JtYWxpemVkQ291bnQgPD0gMC4yKSB7XG4gICAgLy8gMC0yMDog0JfQtdC70LXQvdGL0LlcbiAgICBjb2xvciA9ICcjMjJjNTVlJztcbiAgfSBlbHNlIGlmIChub3JtYWxpemVkQ291bnQgPD0gMC40KSB7XG4gICAgLy8gMjAtNDA6INCX0LXQu9C10L3Ri9C5IOKGkiDQodCy0LXRgtC70L4t0LfQtdC70LXQvdGL0LlcbiAgICBjb25zdCBwcm9ncmVzcyA9IChub3JtYWxpemVkQ291bnQgLSAwLjIpIC8gMC4yO1xuICAgIGNvbG9yID0gaW50ZXJwb2xhdGVDb2xvcignIzIyYzU1ZScsICcjODRjYzE2JywgcHJvZ3Jlc3MpO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6ZWRDb3VudCA8PSAwLjYpIHtcbiAgICAvLyA0MC02MDog0KHQstC10YLQu9C+LdC30LXQu9C10L3Ri9C5IOKGkiDQltC10LvRgtC+LdC30LXQu9C10L3Ri9C5XG4gICAgY29uc3QgcHJvZ3Jlc3MgPSAobm9ybWFsaXplZENvdW50IC0gMC40KSAvIDAuMjtcbiAgICBjb2xvciA9IGludGVycG9sYXRlQ29sb3IoJyM4NGNjMTYnLCAnI2VhYjMwOCcsIHByb2dyZXNzKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemVkQ291bnQgPD0gMC44KSB7XG4gICAgLy8gNjAtODA6INCW0LXQu9GC0L4t0LfQtdC70LXQvdGL0Lkg4oaSINCW0LXQu9GC0YvQuVxuICAgIGNvbnN0IHByb2dyZXNzID0gKG5vcm1hbGl6ZWRDb3VudCAtIDAuNikgLyAwLjI7XG4gICAgY29sb3IgPSBpbnRlcnBvbGF0ZUNvbG9yKCcjZWFiMzA4JywgJyNmNTllMGInLCBwcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gODAtMTAwOiDQltC10LvRgtGL0Lkg4oaSINCe0YDQsNC90LbQtdCy0YvQuVxuICAgIGNvbnN0IHByb2dyZXNzID0gKG5vcm1hbGl6ZWRDb3VudCAtIDAuOCkgLyAwLjI7XG4gICAgY29sb3IgPSBpbnRlcnBvbGF0ZUNvbG9yKCcjZjU5ZTBiJywgJyNlYTU4MGMnLCBwcm9ncmVzcyk7XG4gIH1cbiAgXG4gIC8vINCa0Y3RiNC40YDRg9C10Lwg0YDQtdC30YPQu9GM0YLQsNGCXG4gIHByb2dyZXNzQ29sb3JDYWNoZS5zZXQoY291bnQsIGNvbG9yKTtcbiAgcmV0dXJuIGNvbG9yO1xufVxuXG4vLyDQpNGD0L3QutGG0LjRjyDQtNC70Y8g0LjQvdGC0LXRgNC/0L7Qu9GP0YbQuNC4INC80LXQttC00YMg0LTQstGD0LzRjyDRhtCy0LXRgtCw0LzQuFxuZnVuY3Rpb24gaW50ZXJwb2xhdGVDb2xvcihjb2xvcjE6IHN0cmluZywgY29sb3IyOiBzdHJpbmcsIGZhY3RvcjogbnVtYmVyKTogc3RyaW5nIHtcbiAgLy8g0J/RgNC10L7QsdGA0LDQt9GD0LXQvCBoZXgg0LIgUkdCXG4gIGNvbnN0IGhleDEgPSBjb2xvcjEucmVwbGFjZSgnIycsICcnKTtcbiAgY29uc3QgaGV4MiA9IGNvbG9yMi5yZXBsYWNlKCcjJywgJycpO1xuICBcbiAgY29uc3QgcjEgPSBwYXJzZUludChoZXgxLnN1YnN0cigwLCAyKSwgMTYpO1xuICBjb25zdCBnMSA9IHBhcnNlSW50KGhleDEuc3Vic3RyKDIsIDIpLCAxNik7XG4gIGNvbnN0IGIxID0gcGFyc2VJbnQoaGV4MS5zdWJzdHIoNCwgMiksIDE2KTtcbiAgXG4gIGNvbnN0IHIyID0gcGFyc2VJbnQoaGV4Mi5zdWJzdHIoMCwgMiksIDE2KTtcbiAgY29uc3QgZzIgPSBwYXJzZUludChoZXgyLnN1YnN0cigyLCAyKSwgMTYpO1xuICBjb25zdCBiMiA9IHBhcnNlSW50KGhleDIuc3Vic3RyKDQsIDIpLCAxNik7XG4gIFxuICAvLyDQmNC90YLQtdGA0L/QvtC70LjRgNGD0LXQvCDQutCw0LbQtNGL0Lkg0LrQsNC90LDQu1xuICBjb25zdCByID0gTWF0aC5yb3VuZChyMSArIChyMiAtIHIxKSAqIGZhY3Rvcik7XG4gIGNvbnN0IGcgPSBNYXRoLnJvdW5kKGcxICsgKGcyIC0gZzEpICogZmFjdG9yKTtcbiAgY29uc3QgYiA9IE1hdGgucm91bmQoYjEgKyAoYjIgLSBiMSkgKiBmYWN0b3IpO1xuICBcbiAgLy8g0J/RgNC10L7QsdGA0LDQt9GD0LXQvCDQvtCx0YDQsNGC0L3QviDQsiBoZXhcbiAgcmV0dXJuIGAjJHtyLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpfSR7Zy50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKX0ke2IudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyl9YDtcbn1cblxuLy8g0JrRjdGIINC00LvRjyDRgNCw0YHRh9C10YLQsCDQstC+0LfRgNCw0YHRgtCwINCz0YDRg9C/0L9cbmNvbnN0IGdyb3VwQWdlQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xubGV0IGxhc3RIaXN0b3J5TGVuZ3RoID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUdyb3VwQWdlKGhpc3Rvcnk6IFJvdWxldHRlTnVtYmVyW10sIGdyb3VwOiBudW1iZXJbXSk6IG51bWJlciB7XG4gIC8vINCe0YfQuNGJ0LDQtdC8INC60Y3RiCDQtdGB0LvQuCDQuNGB0YLQvtGA0LjRjyDQuNC30LzQtdC90LjQu9Cw0YHRjFxuICBpZiAoaGlzdG9yeS5sZW5ndGggIT09IGxhc3RIaXN0b3J5TGVuZ3RoKSB7XG4gICAgZ3JvdXBBZ2VDYWNoZS5jbGVhcigpO1xuICAgIGxhc3RIaXN0b3J5TGVuZ3RoID0gaGlzdG9yeS5sZW5ndGg7XG4gIH1cbiAgXG4gIC8vINCh0L7Qt9C00LDQtdC8INGD0L3QuNC60LDQu9GM0L3Ri9C5INC60LvRjtGHINC00LvRjyDQs9GA0YPQv9C/0YtcbiAgY29uc3QgZ3JvdXBLZXkgPSBncm91cC5zb3J0KCkuam9pbignLCcpO1xuICBcbiAgLy8g0J/RgNC+0LLQtdGA0Y/QtdC8INC60Y3RiFxuICBpZiAoZ3JvdXBBZ2VDYWNoZS5oYXMoZ3JvdXBLZXkpKSB7XG4gICAgcmV0dXJuIGdyb3VwQWdlQ2FjaGUuZ2V0KGdyb3VwS2V5KSE7XG4gIH1cbiAgXG4gIGxldCBncm91cEFnZSA9IGhpc3RvcnkubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gaGlzdG9yeS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChncm91cC5pbmNsdWRlcyhoaXN0b3J5W2ldIGFzIG51bWJlcikpIHtcbiAgICAgIGdyb3VwQWdlID0gaGlzdG9yeS5sZW5ndGggLSAxIC0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBcbiAgLy8g0JrRjdGI0LjRgNGD0LXQvCDRgNC10LfRg9C70YzRgtCw0YJcbiAgZ3JvdXBBZ2VDYWNoZS5zZXQoZ3JvdXBLZXksIGdyb3VwQWdlKTtcbiAgcmV0dXJuIGdyb3VwQWdlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZFJlcGVhdHMoaGlzdG9yeTogUm91bGV0dGVOdW1iZXJbXSk6IFJlcGVhdFNlcmllc1tdIHtcbiAgY29uc3QgcmVwZWF0czogUmVwZWF0U2VyaWVzW10gPSBbXTtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoaSA8IGhpc3RvcnkubGVuZ3RoIC0gMSkge1xuICAgIGxldCBqID0gaTtcbiAgICB3aGlsZSAoaiArIDEgPCBoaXN0b3J5Lmxlbmd0aCAmJiBoaXN0b3J5W2pdID09PSBoaXN0b3J5W2ogKyAxXSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgICBpZiAoaiA+IGkpIHtcbiAgICAgIHJlcGVhdHMucHVzaCh7IHZhbHVlOiBoaXN0b3J5W2ldLCBzdGFydDogaSArIDEsIGxlbmd0aDogaiAtIGkgKyAxIH0pO1xuICAgICAgaSA9IGogKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXBlYXRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVwZWF0SW5kZXhlcyhoaXN0b3J5OiBSb3VsZXR0ZU51bWJlcltdKTogU2V0PG51bWJlcj4ge1xuICBjb25zdCByZXBlYXRJbmRleGVzID0gbmV3IFNldDxudW1iZXI+KCk7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBoaXN0b3J5Lmxlbmd0aCAtIDEpIHtcbiAgICBsZXQgaiA9IGk7XG4gICAgd2hpbGUgKGogKyAxIDwgaGlzdG9yeS5sZW5ndGggJiYgaGlzdG9yeVtqXSA9PT0gaGlzdG9yeVtqICsgMV0pIHtcbiAgICAgIGorKztcbiAgICB9XG4gICAgaWYgKGogPiBpKSB7XG4gICAgICBmb3IgKGxldCBrID0gaTsgayA8PSBqOyBrKyspIHJlcGVhdEluZGV4ZXMuYWRkKGspO1xuICAgICAgaSA9IGogKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXBlYXRJbmRleGVzO1xufSAiXSwibmFtZXMiOlsiUkVEX05VTUJFUlMiLCJCTEFDS19OVU1CRVJTIiwiZ2V0Q29udHJhc3RUZXh0IiwiYmdDb2xvciIsInN0YXJ0c1dpdGgiLCJzbGljZSIsInIiLCJnIiwiYiIsImxlbmd0aCIsInBhcnNlSW50IiwiYnJpZ2h0bmVzcyIsImdldE51bWJlckNvbG9yIiwibnVtIiwiaGFzIiwiY2FsY3VsYXRlQWdlTWFwIiwiaGlzdG9yeSIsIkRFQlVHX0xPR1MiLCJwcm9jZXNzIiwiY29uc29sZSIsImxvZyIsImFnZU1hcCIsImkiLCJTdHJpbmciLCJPYmplY3QiLCJrZXlzIiwicHJvZ3Jlc3NDb2xvckNhY2hlIiwiTWFwIiwiZ2V0UHJvZ3Jlc3NDb2xvciIsImNvdW50IiwiZ2V0Iiwibm9ybWFsaXplZENvdW50IiwiTWF0aCIsIm1pbiIsImNvbG9yIiwicHJvZ3Jlc3MiLCJpbnRlcnBvbGF0ZUNvbG9yIiwic2V0IiwiY29sb3IxIiwiY29sb3IyIiwiZmFjdG9yIiwiaGV4MSIsInJlcGxhY2UiLCJoZXgyIiwicjEiLCJzdWJzdHIiLCJnMSIsImIxIiwicjIiLCJnMiIsImIyIiwicm91bmQiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiZ3JvdXBBZ2VDYWNoZSIsImxhc3RIaXN0b3J5TGVuZ3RoIiwiY2FsY3VsYXRlR3JvdXBBZ2UiLCJncm91cCIsImNsZWFyIiwiZ3JvdXBLZXkiLCJzb3J0Iiwiam9pbiIsImdyb3VwQWdlIiwiaW5jbHVkZXMiLCJmaW5kUmVwZWF0cyIsInJlcGVhdHMiLCJqIiwicHVzaCIsInZhbHVlIiwic3RhcnQiLCJnZXRSZXBlYXRJbmRleGVzIiwicmVwZWF0SW5kZXhlcyIsIlNldCIsImsiLCJhZGQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/casino/utils/rouletteUtils.ts\n"));

/***/ })

});