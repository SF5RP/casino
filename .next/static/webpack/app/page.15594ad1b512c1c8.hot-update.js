"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/casino/utils/rouletteUtils.ts":
/*!******************************************************!*\
  !*** ./src/components/casino/utils/rouletteUtils.ts ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateAgeMap: () => (/* binding */ calculateAgeMap),\n/* harmony export */   calculateGroupAge: () => (/* binding */ calculateGroupAge),\n/* harmony export */   findRepeats: () => (/* binding */ findRepeats),\n/* harmony export */   getContrastText: () => (/* binding */ getContrastText),\n/* harmony export */   getNumberColor: () => (/* binding */ getNumberColor),\n/* harmony export */   getProgressColor: () => (/* binding */ getProgressColor),\n/* harmony export */   getRepeatIndexes: () => (/* binding */ getRepeatIndexes)\n/* harmony export */ });\n/* harmony import */ var _constants_rouletteConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/rouletteConstants */ \"(app-pages-browser)/./src/components/casino/constants/rouletteConstants.ts\");\n\nfunction getContrastText(bgColor) {\n    // Удаляем # если есть\n    if (bgColor.startsWith('#')) bgColor = bgColor.slice(1);\n    // Преобразуем в rgb\n    let r = 0, g = 0, b = 0;\n    if (bgColor.length === 3) {\n        r = parseInt(bgColor[0] + bgColor[0], 16);\n        g = parseInt(bgColor[1] + bgColor[1], 16);\n        b = parseInt(bgColor[2] + bgColor[2], 16);\n    } else if (bgColor.length === 6) {\n        r = parseInt(bgColor.slice(0, 2), 16);\n        g = parseInt(bgColor.slice(2, 4), 16);\n        b = parseInt(bgColor.slice(4, 6), 16);\n    }\n    // Яркость по формуле WCAG\n    const brightness = (r * 299 + g * 587 + b * 114) / 1000;\n    return brightness > 140 ? '#222' : '#fff';\n}\nfunction getNumberColor(num) {\n    if (num === 0 || num === '00') return '#2ecc71'; // зеленый для 0 и 00\n    if (_constants_rouletteConstants__WEBPACK_IMPORTED_MODULE_0__.RED_NUMBERS.has(num)) return '#e74c3c';\n    if (_constants_rouletteConstants__WEBPACK_IMPORTED_MODULE_0__.BLACK_NUMBERS.has(num)) return '#2c3e50';\n    return '#bdc3c7';\n}\nfunction calculateAgeMap(history) {\n    const DEBUG_LOGS = \"development\" === 'development';\n    if (DEBUG_LOGS) {\n        console.log(\"\\uD83D\\uDDFA️ Расчет AgeMap для \".concat(history.length, \" элементов истории\"));\n    }\n    const ageMap = {};\n    const reversedHistory = [\n        ...history\n    ].reverse(); // Создаем один раз\n    for(let i = 0; i <= 36; i++){\n        const index = reversedHistory.findIndex((v)=>v === i);\n        ageMap[String(i)] = index === -1 ? history.length : index;\n    }\n    ageMap['00'] = reversedHistory.findIndex((v)=>v === '00');\n    if (ageMap['00'] === -1) ageMap['00'] = history.length;\n    if (DEBUG_LOGS) {\n        console.log(\"✅ AgeMap готов (\".concat(Object.keys(ageMap).length, \" чисел)\"));\n    }\n    return ageMap;\n}\n// Кэш для цветов прогресса\nconst progressColorCache = new Map();\nfunction getProgressColor(count) {\n    // Проверяем кэш\n    if (progressColorCache.has(count)) {\n        return progressColorCache.get(count);\n    }\n    // Плавная градация от зеленого через желтый к оранжевому\n    // Нормализуем значение от 0 до 1 для диапазона 0-100\n    const normalizedCount = Math.min(count / 100, 1);\n    let color;\n    if (normalizedCount <= 0.2) {\n        // 0-20: Зеленый\n        color = '#22c55e';\n    } else if (normalizedCount <= 0.4) {\n        // 20-40: Зеленый → Светло-зеленый\n        const progress = (normalizedCount - 0.2) / 0.2;\n        color = interpolateColor('#22c55e', '#84cc16', progress);\n    } else if (normalizedCount <= 0.6) {\n        // 40-60: Светло-зеленый → Желто-зеленый\n        const progress = (normalizedCount - 0.4) / 0.2;\n        color = interpolateColor('#84cc16', '#eab308', progress);\n    } else if (normalizedCount <= 0.8) {\n        // 60-80: Желто-зеленый → Желтый\n        const progress = (normalizedCount - 0.6) / 0.2;\n        color = interpolateColor('#eab308', '#f59e0b', progress);\n    } else {\n        // 80-100: Желтый → Оранжевый\n        const progress = (normalizedCount - 0.8) / 0.2;\n        color = interpolateColor('#f59e0b', '#ea580c', progress);\n    }\n    // Кэшируем результат\n    progressColorCache.set(count, color);\n    return color;\n}\n// Функция для интерполяции между двумя цветами\nfunction interpolateColor(color1, color2, factor) {\n    // Преобразуем hex в RGB\n    const hex1 = color1.replace('#', '');\n    const hex2 = color2.replace('#', '');\n    const r1 = parseInt(hex1.substr(0, 2), 16);\n    const g1 = parseInt(hex1.substr(2, 2), 16);\n    const b1 = parseInt(hex1.substr(4, 2), 16);\n    const r2 = parseInt(hex2.substr(0, 2), 16);\n    const g2 = parseInt(hex2.substr(2, 2), 16);\n    const b2 = parseInt(hex2.substr(4, 2), 16);\n    // Интерполируем каждый канал\n    const r = Math.round(r1 + (r2 - r1) * factor);\n    const g = Math.round(g1 + (g2 - g1) * factor);\n    const b = Math.round(b1 + (b2 - b1) * factor);\n    // Преобразуем обратно в hex\n    return \"#\".concat(r.toString(16).padStart(2, '0')).concat(g.toString(16).padStart(2, '0')).concat(b.toString(16).padStart(2, '0'));\n}\n// Кэш для расчета возраста групп\nconst groupAgeCache = new Map();\nlet lastHistoryLength = 0;\nfunction calculateGroupAge(history, group) {\n    // Очищаем кэш если история изменилась\n    if (history.length !== lastHistoryLength) {\n        groupAgeCache.clear();\n        lastHistoryLength = history.length;\n    }\n    // Создаем уникальный ключ для группы\n    const groupKey = group.sort().join(',');\n    // Проверяем кэш\n    if (groupAgeCache.has(groupKey)) {\n        return groupAgeCache.get(groupKey);\n    }\n    let groupAge = history.length;\n    for(let i = history.length - 1; i >= 0; i--){\n        if (group.includes(history[i])) {\n            groupAge = history.length - 1 - i;\n            break;\n        }\n    }\n    // Кэшируем результат\n    groupAgeCache.set(groupKey, groupAge);\n    return groupAge;\n}\nfunction findRepeats(history) {\n    const repeats = [];\n    let i = 0;\n    while(i < history.length - 1){\n        let j = i;\n        while(j + 1 < history.length && history[j] === history[j + 1]){\n            j++;\n        }\n        if (j > i) {\n            repeats.push({\n                value: history[i],\n                start: i + 1,\n                length: j - i + 1\n            });\n            i = j + 1;\n        } else {\n            i++;\n        }\n    }\n    return repeats;\n}\nfunction getRepeatIndexes(history) {\n    const repeatIndexes = new Set();\n    let i = 0;\n    while(i < history.length - 1){\n        let j = i;\n        while(j + 1 < history.length && history[j] === history[j + 1]){\n            j++;\n        }\n        if (j > i) {\n            for(let k = i; k <= j; k++)repeatIndexes.add(k);\n            i = j + 1;\n        } else {\n            i++;\n        }\n    }\n    return repeatIndexes;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Nhc2luby91dGlscy9yb3VsZXR0ZVV0aWxzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTRFO0FBR3JFLFNBQVNFLGdCQUFnQkMsT0FBZTtJQUM3QyxzQkFBc0I7SUFDdEIsSUFBSUEsUUFBUUMsVUFBVSxDQUFDLE1BQU1ELFVBQVVBLFFBQVFFLEtBQUssQ0FBQztJQUNyRCxvQkFBb0I7SUFDcEIsSUFBSUMsSUFBSSxHQUFHQyxJQUFJLEdBQUdDLElBQUk7SUFDdEIsSUFBSUwsUUFBUU0sTUFBTSxLQUFLLEdBQUc7UUFDeEJILElBQUlJLFNBQVNQLE9BQU8sQ0FBQyxFQUFFLEdBQUdBLE9BQU8sQ0FBQyxFQUFFLEVBQUU7UUFDdENJLElBQUlHLFNBQVNQLE9BQU8sQ0FBQyxFQUFFLEdBQUdBLE9BQU8sQ0FBQyxFQUFFLEVBQUU7UUFDdENLLElBQUlFLFNBQVNQLE9BQU8sQ0FBQyxFQUFFLEdBQUdBLE9BQU8sQ0FBQyxFQUFFLEVBQUU7SUFDeEMsT0FBTyxJQUFJQSxRQUFRTSxNQUFNLEtBQUssR0FBRztRQUMvQkgsSUFBSUksU0FBU1AsUUFBUUUsS0FBSyxDQUFDLEdBQUcsSUFBSTtRQUNsQ0UsSUFBSUcsU0FBU1AsUUFBUUUsS0FBSyxDQUFDLEdBQUcsSUFBSTtRQUNsQ0csSUFBSUUsU0FBU1AsUUFBUUUsS0FBSyxDQUFDLEdBQUcsSUFBSTtJQUNwQztJQUNBLDBCQUEwQjtJQUMxQixNQUFNTSxhQUFhLENBQUNMLElBQUksTUFBTUMsSUFBSSxNQUFNQyxJQUFJLEdBQUUsSUFBSztJQUNuRCxPQUFPRyxhQUFhLE1BQU0sU0FBUztBQUNyQztBQUVPLFNBQVNDLGVBQWVDLEdBQW1CO0lBQ2hELElBQUlBLFFBQVEsS0FBS0EsUUFBUSxNQUFNLE9BQU8sV0FBVyxxQkFBcUI7SUFDdEUsSUFBSWIscUVBQVdBLENBQUNjLEdBQUcsQ0FBQ0QsTUFBZ0IsT0FBTztJQUMzQyxJQUFJWix1RUFBYUEs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R0FBR3NELEtBQUtQLEdBQUdPLElBQUtGLGNBQWNHLEdBQUcsQ0FBQ0Q7WUFDL0N0RCxJQUFJK0MsSUFBSTtRQUNWLE9BQU87WUFDTC9DO1FBQ0Y7SUFDRjtJQUNBLE9BQU9vRDtBQUNUIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHBsb3RuaWtvdmF5XFxXZWJzdG9ybVByb2plY3RzXFxjYXNpbm9cXHNyY1xcY29tcG9uZW50c1xcY2FzaW5vXFx1dGlsc1xccm91bGV0dGVVdGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSRURfTlVNQkVSUywgQkxBQ0tfTlVNQkVSUyB9IGZyb20gJy4uL2NvbnN0YW50cy9yb3VsZXR0ZUNvbnN0YW50cyc7XHJcbmltcG9ydCB0eXBlIHsgUm91bGV0dGVOdW1iZXIsIFJlcGVhdFNlcmllcywgQWdlTWFwIH0gZnJvbSAnLi4vdHlwZXMvcm91bGV0dGVUeXBlcyc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udHJhc3RUZXh0KGJnQ29sb3I6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgLy8g0KPQtNCw0LvRj9C10LwgIyDQtdGB0LvQuCDQtdGB0YLRjFxyXG4gIGlmIChiZ0NvbG9yLnN0YXJ0c1dpdGgoJyMnKSkgYmdDb2xvciA9IGJnQ29sb3Iuc2xpY2UoMSk7XHJcbiAgLy8g0J/RgNC10L7QsdGA0LDQt9GD0LXQvCDQsiByZ2JcclxuICBsZXQgciA9IDAsIGcgPSAwLCBiID0gMDtcclxuICBpZiAoYmdDb2xvci5sZW5ndGggPT09IDMpIHtcclxuICAgIHIgPSBwYXJzZUludChiZ0NvbG9yWzBdICsgYmdDb2xvclswXSwgMTYpO1xyXG4gICAgZyA9IHBhcnNlSW50KGJnQ29sb3JbMV0gKyBiZ0NvbG9yWzFdLCAxNik7XHJcbiAgICBiID0gcGFyc2VJbnQoYmdDb2xvclsyXSArIGJnQ29sb3JbMl0sIDE2KTtcclxuICB9IGVsc2UgaWYgKGJnQ29sb3IubGVuZ3RoID09PSA2KSB7XHJcbiAgICByID0gcGFyc2VJbnQoYmdDb2xvci5zbGljZSgwLCAyKSwgMTYpO1xyXG4gICAgZyA9IHBhcnNlSW50KGJnQ29sb3Iuc2xpY2UoMiwgNCksIDE2KTtcclxuICAgIGIgPSBwYXJzZUludChiZ0NvbG9yLnNsaWNlKDQsIDYpLCAxNik7XHJcbiAgfVxyXG4gIC8vINCv0YDQutC+0YHRgtGMINC/0L4g0YTQvtGA0LzRg9C70LUgV0NBR1xyXG4gIGNvbnN0IGJyaWdodG5lc3MgPSAociAqIDI5OSArIGcgKiA1ODcgKyBiICogMTE0KSAvIDEwMDA7XHJcbiAgcmV0dXJuIGJyaWdodG5lc3MgPiAxNDAgPyAnIzIyMicgOiAnI2ZmZic7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXROdW1iZXJDb2xvcihudW06IFJvdWxldHRlTnVtYmVyKTogc3RyaW5nIHtcclxuICBpZiAobnVtID09PSAwIHx8IG51bSA9PT0gJzAwJykgcmV0dXJuICcjMmVjYzcxJzsgLy8g0LfQtdC70LXQvdGL0Lkg0LTQu9GPIDAg0LggMDBcclxuICBpZiAoUkVEX05VTUJFUlMuaGFzKG51bSBhcyBudW1iZXIpKSByZXR1cm4gJyNlNzRjM2MnO1xyXG4gIGlmIChCTEFDS19OVU1CRVJTLmhhcyhudW0gYXMgbnVtYmVyKSkgcmV0dXJuICcjMmMzZTUwJztcclxuICByZXR1cm4gJyNiZGMzYzcnO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQWdlTWFwKGhpc3Rvcnk6IFJvdWxldHRlTnVtYmVyW10pOiBBZ2VNYXAge1xyXG4gIGNvbnN0IERFQlVHX0xPR1MgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JztcclxuICBcclxuICBpZiAoREVCVUdfTE9HUykge1xyXG4gICAgY29uc29sZS5sb2coYPCfl7rvuI8g0KDQsNGB0YfQtdGCIEFnZU1hcCDQtNC70Y8gJHtoaXN0b3J5Lmxlbmd0aH0g0Y3Qu9C10LzQtdC90YLQvtCyINC40YHRgtC+0YDQuNC4YCk7XHJcbiAgfVxyXG4gIFxyXG4gIGNvbnN0IGFnZU1hcDogQWdlTWFwID0ge307XHJcbiAgY29uc3QgcmV2ZXJzZWRIaXN0b3J5ID0gWy4uLmhpc3RvcnldLnJldmVyc2UoKTsgLy8g0KHQvtC30LTQsNC10Lwg0L7QtNC40L0g0YDQsNC3XHJcbiAgXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMzY7IGkrKykge1xyXG4gICAgY29uc3QgaW5kZXggPSByZXZlcnNlZEhpc3RvcnkuZmluZEluZGV4KCh2KSA9PiB2ID09PSBpKTtcclxuICAgIGFnZU1hcFtTdHJpbmcoaSldID0gaW5kZXggPT09IC0xID8gaGlzdG9yeS5sZW5ndGggOiBpbmRleDtcclxuICB9XHJcbiAgXHJcbiAgYWdlTWFwWycwMCddID0gcmV2ZXJzZWRIaXN0b3J5LmZpbmRJbmRleCgodikgPT4gdiA9PT0gJzAwJyk7XHJcbiAgaWYgKGFnZU1hcFsnMDAnXSA9PT0gLTEpIGFnZU1hcFsnMDAnXSA9IGhpc3RvcnkubGVuZ3RoO1xyXG4gIFxyXG4gIGlmIChERUJVR19MT0dTKSB7XHJcbiAgICBjb25zb2xlLmxvZyhg4pyFIEFnZU1hcCDQs9C+0YLQvtCyICgke09iamVjdC5rZXlzKGFnZU1hcCkubGVuZ3RofSDRh9C40YHQtdC7KWApO1xyXG4gIH1cclxuICByZXR1cm4gYWdlTWFwO1xyXG59XHJcblxyXG4vLyDQmtGN0Ygg0LTQu9GPINGG0LLQtdGC0L7QsiDQv9GA0L7Qs9GA0LXRgdGB0LBcclxuY29uc3QgcHJvZ3Jlc3NDb2xvckNhY2hlID0gbmV3IE1hcDxudW1iZXIsIHN0cmluZz4oKTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9ncmVzc0NvbG9yKGNvdW50OiBudW1iZXIpOiBzdHJpbmcge1xyXG4gIC8vINCf0YDQvtCy0LXRgNGP0LXQvCDQutGN0YhcclxuICBpZiAocHJvZ3Jlc3NDb2xvckNhY2hlLmhhcyhjb3VudCkpIHtcclxuICAgIHJldHVybiBwcm9ncmVzc0NvbG9yQ2FjaGUuZ2V0KGNvdW50KSE7XHJcbiAgfVxyXG4gIFxyXG4gIC8vINCf0LvQsNCy0L3QsNGPINCz0YDQsNC00LDRhtC40Y8g0L7RgiDQt9C10LvQtdC90L7Qs9C+INGH0LXRgNC10Lcg0LbQtdC70YLRi9C5INC6INC+0YDQsNC90LbQtdCy0L7QvNGDXHJcbiAgLy8g0J3QvtGA0LzQsNC70LjQt9GD0LXQvCDQt9C90LDRh9C10L3QuNC1INC+0YIgMCDQtNC+IDEg0LTQu9GPINC00LjQsNC/0LDQt9C+0L3QsCAwLTEwMFxyXG4gIGNvbnN0IG5vcm1hbGl6ZWRDb3VudCA9IE1hdGgubWluKGNvdW50IC8gMTAwLCAxKTtcclxuICBcclxuICBsZXQgY29sb3I6IHN0cmluZztcclxuICBcclxuICBpZiAobm9ybWFsaXplZENvdW50IDw9IDAuMikge1xyXG4gICAgLy8gMC0yMDog0JfQtdC70LXQvdGL0LlcclxuICAgIGNvbG9yID0gJyMyMmM1NWUnO1xyXG4gIH0gZWxzZSBpZiAobm9ybWFsaXplZENvdW50IDw9IDAuNCkge1xyXG4gICAgLy8gMjAtNDA6INCX0LXQu9C10L3Ri9C5IOKGkiDQodCy0LXRgtC70L4t0LfQtdC70LXQvdGL0LlcclxuICAgIGNvbnN0IHByb2dyZXNzID0gKG5vcm1hbGl6ZWRDb3VudCAtIDAuMikgLyAwLjI7XHJcbiAgICBjb2xvciA9IGludGVycG9sYXRlQ29sb3IoJyMyMmM1NWUnLCAnIzg0Y2MxNicsIHByb2dyZXNzKTtcclxuICB9IGVsc2UgaWYgKG5vcm1hbGl6ZWRDb3VudCA8PSAwLjYpIHtcclxuICAgIC8vIDQwLTYwOiDQodCy0LXRgtC70L4t0LfQtdC70LXQvdGL0Lkg4oaSINCW0LXQu9GC0L4t0LfQtdC70LXQvdGL0LlcclxuICAgIGNvbnN0IHByb2dyZXNzID0gKG5vcm1hbGl6ZWRDb3VudCAtIDAuNCkgLyAwLjI7XHJcbiAgICBjb2xvciA9IGludGVycG9sYXRlQ29sb3IoJyM4NGNjMTYnLCAnI2VhYjMwOCcsIHByb2dyZXNzKTtcclxuICB9IGVsc2UgaWYgKG5vcm1hbGl6ZWRDb3VudCA8PSAwLjgpIHtcclxuICAgIC8vIDYwLTgwOiDQltC10LvRgtC+LdC30LXQu9C10L3Ri9C5IOKGkiDQltC10LvRgtGL0LlcclxuICAgIGNvbnN0IHByb2dyZXNzID0gKG5vcm1hbGl6ZWRDb3VudCAtIDAuNikgLyAwLjI7XHJcbiAgICBjb2xvciA9IGludGVycG9sYXRlQ29sb3IoJyNlYWIzMDgnLCAnI2Y1OWUwYicsIHByb2dyZXNzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gODAtMTAwOiDQltC10LvRgtGL0Lkg4oaSINCe0YDQsNC90LbQtdCy0YvQuVxyXG4gICAgY29uc3QgcHJvZ3Jlc3MgPSAobm9ybWFsaXplZENvdW50IC0gMC44KSAvIDAuMjtcclxuICAgIGNvbG9yID0gaW50ZXJwb2xhdGVDb2xvcignI2Y1OWUwYicsICcjZWE1ODBjJywgcHJvZ3Jlc3MpO1xyXG4gIH1cclxuICBcclxuICAvLyDQmtGN0YjQuNGA0YPQtdC8INGA0LXQt9GD0LvRjNGC0LDRglxyXG4gIHByb2dyZXNzQ29sb3JDYWNoZS5zZXQoY291bnQsIGNvbG9yKTtcclxuICByZXR1cm4gY29sb3I7XHJcbn1cclxuXHJcbi8vINCk0YPQvdC60YbQuNGPINC00LvRjyDQuNC90YLQtdGA0L/QvtC70Y/RhtC40Lgg0LzQtdC20LTRgyDQtNCy0YPQvNGPINGG0LLQtdGC0LDQvNC4XHJcbmZ1bmN0aW9uIGludGVycG9sYXRlQ29sb3IoY29sb3IxOiBzdHJpbmcsIGNvbG9yMjogc3RyaW5nLCBmYWN0b3I6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgLy8g0J/RgNC10L7QsdGA0LDQt9GD0LXQvCBoZXgg0LIgUkdCXHJcbiAgY29uc3QgaGV4MSA9IGNvbG9yMS5yZXBsYWNlKCcjJywgJycpO1xyXG4gIGNvbnN0IGhleDIgPSBjb2xvcjIucmVwbGFjZSgnIycsICcnKTtcclxuICBcclxuICBjb25zdCByMSA9IHBhcnNlSW50KGhleDEuc3Vic3RyKDAsIDIpLCAxNik7XHJcbiAgY29uc3QgZzEgPSBwYXJzZUludChoZXgxLnN1YnN0cigyLCAyKSwgMTYpO1xyXG4gIGNvbnN0IGIxID0gcGFyc2VJbnQoaGV4MS5zdWJzdHIoNCwgMiksIDE2KTtcclxuICBcclxuICBjb25zdCByMiA9IHBhcnNlSW50KGhleDIuc3Vic3RyKDAsIDIpLCAxNik7XHJcbiAgY29uc3QgZzIgPSBwYXJzZUludChoZXgyLnN1YnN0cigyLCAyKSwgMTYpO1xyXG4gIGNvbnN0IGIyID0gcGFyc2VJbnQoaGV4Mi5zdWJzdHIoNCwgMiksIDE2KTtcclxuICBcclxuICAvLyDQmNC90YLQtdGA0L/QvtC70LjRgNGD0LXQvCDQutCw0LbQtNGL0Lkg0LrQsNC90LDQu1xyXG4gIGNvbnN0IHIgPSBNYXRoLnJvdW5kKHIxICsgKHIyIC0gcjEpICogZmFjdG9yKTtcclxuICBjb25zdCBnID0gTWF0aC5yb3VuZChnMSArIChnMiAtIGcxKSAqIGZhY3Rvcik7XHJcbiAgY29uc3QgYiA9IE1hdGgucm91bmQoYjEgKyAoYjIgLSBiMSkgKiBmYWN0b3IpO1xyXG4gIFxyXG4gIC8vINCf0YDQtdC+0LHRgNCw0LfRg9C10Lwg0L7QsdGA0LDRgtC90L4g0LIgaGV4XHJcbiAgcmV0dXJuIGAjJHtyLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpfSR7Zy50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKX0ke2IudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyl9YDtcclxufVxyXG5cclxuLy8g0JrRjdGIINC00LvRjyDRgNCw0YHRh9C10YLQsCDQstC+0LfRgNCw0YHRgtCwINCz0YDRg9C/0L9cclxuY29uc3QgZ3JvdXBBZ2VDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XHJcbmxldCBsYXN0SGlzdG9yeUxlbmd0aCA9IDA7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlR3JvdXBBZ2UoaGlzdG9yeTogUm91bGV0dGVOdW1iZXJbXSwgZ3JvdXA6IG51bWJlcltdKTogbnVtYmVyIHtcclxuICAvLyDQntGH0LjRidCw0LXQvCDQutGN0Ygg0LXRgdC70Lgg0LjRgdGC0L7RgNC40Y8g0LjQt9C80LXQvdC40LvQsNGB0YxcclxuICBpZiAoaGlzdG9yeS5sZW5ndGggIT09IGxhc3RIaXN0b3J5TGVuZ3RoKSB7XHJcbiAgICBncm91cEFnZUNhY2hlLmNsZWFyKCk7XHJcbiAgICBsYXN0SGlzdG9yeUxlbmd0aCA9IGhpc3RvcnkubGVuZ3RoO1xyXG4gIH1cclxuICBcclxuICAvLyDQodC+0LfQtNCw0LXQvCDRg9C90LjQutCw0LvRjNC90YvQuSDQutC70Y7RhyDQtNC70Y8g0LPRgNGD0L/Qv9GLXHJcbiAgY29uc3QgZ3JvdXBLZXkgPSBncm91cC5zb3J0KCkuam9pbignLCcpO1xyXG4gIFxyXG4gIC8vINCf0YDQvtCy0LXRgNGP0LXQvCDQutGN0YhcclxuICBpZiAoZ3JvdXBBZ2VDYWNoZS5oYXMoZ3JvdXBLZXkpKSB7XHJcbiAgICByZXR1cm4gZ3JvdXBBZ2VDYWNoZS5nZXQoZ3JvdXBLZXkpITtcclxuICB9XHJcbiAgXHJcbiAgbGV0IGdyb3VwQWdlID0gaGlzdG9yeS5sZW5ndGg7XHJcbiAgZm9yIChsZXQgaSA9IGhpc3RvcnkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgIGlmIChncm91cC5pbmNsdWRlcyhoaXN0b3J5W2ldIGFzIG51bWJlcikpIHtcclxuICAgICAgZ3JvdXBBZ2UgPSBoaXN0b3J5Lmxlbmd0aCAtIDEgLSBpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8g0JrRjdGI0LjRgNGD0LXQvCDRgNC10LfRg9C70YzRgtCw0YJcclxuICBncm91cEFnZUNhY2hlLnNldChncm91cEtleSwgZ3JvdXBBZ2UpO1xyXG4gIHJldHVybiBncm91cEFnZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRSZXBlYXRzKGhpc3Rvcnk6IFJvdWxldHRlTnVtYmVyW10pOiBSZXBlYXRTZXJpZXNbXSB7XHJcbiAgY29uc3QgcmVwZWF0czogUmVwZWF0U2VyaWVzW10gPSBbXTtcclxuICBsZXQgaSA9IDA7XHJcbiAgd2hpbGUgKGkgPCBoaXN0b3J5Lmxlbmd0aCAtIDEpIHtcclxuICAgIGxldCBqID0gaTtcclxuICAgIHdoaWxlIChqICsgMSA8IGhpc3RvcnkubGVuZ3RoICYmIGhpc3Rvcnlbal0gPT09IGhpc3RvcnlbaiArIDFdKSB7XHJcbiAgICAgIGorKztcclxuICAgIH1cclxuICAgIGlmIChqID4gaSkge1xyXG4gICAgICByZXBlYXRzLnB1c2goeyB2YWx1ZTogaGlzdG9yeVtpXSwgc3RhcnQ6IGkgKyAxLCBsZW5ndGg6IGogLSBpICsgMSB9KTtcclxuICAgICAgaSA9IGogKyAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaSsrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVwZWF0cztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlcGVhdEluZGV4ZXMoaGlzdG9yeTogUm91bGV0dGVOdW1iZXJbXSk6IFNldDxudW1iZXI+IHtcclxuICBjb25zdCByZXBlYXRJbmRleGVzID0gbmV3IFNldDxudW1iZXI+KCk7XHJcbiAgbGV0IGkgPSAwO1xyXG4gIHdoaWxlIChpIDwgaGlzdG9yeS5sZW5ndGggLSAxKSB7XHJcbiAgICBsZXQgaiA9IGk7XHJcbiAgICB3aGlsZSAoaiArIDEgPCBoaXN0b3J5Lmxlbmd0aCAmJiBoaXN0b3J5W2pdID09PSBoaXN0b3J5W2ogKyAxXSkge1xyXG4gICAgICBqKys7XHJcbiAgICB9XHJcbiAgICBpZiAoaiA+IGkpIHtcclxuICAgICAgZm9yIChsZXQgayA9IGk7IGsgPD0gajsgaysrKSByZXBlYXRJbmRleGVzLmFkZChrKTtcclxuICAgICAgaSA9IGogKyAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaSsrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVwZWF0SW5kZXhlcztcclxufSAiXSwibmFtZXMiOlsiUkVEX05VTUJFUlMiLCJCTEFDS19OVU1CRVJTIiwiZ2V0Q29udHJhc3RUZXh0IiwiYmdDb2xvciIsInN0YXJ0c1dpdGgiLCJzbGljZSIsInIiLCJnIiwiYiIsImxlbmd0aCIsInBhcnNlSW50IiwiYnJpZ2h0bmVzcyIsImdldE51bWJlckNvbG9yIiwibnVtIiwiaGFzIiwiY2FsY3VsYXRlQWdlTWFwIiwiaGlzdG9yeSIsIkRFQlVHX0xPR1MiLCJwcm9jZXNzIiwiY29uc29sZSIsImxvZyIsImFnZU1hcCIsInJldmVyc2VkSGlzdG9yeSIsInJldmVyc2UiLCJpIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJ2IiwiU3RyaW5nIiwiT2JqZWN0Iiwia2V5cyIsInByb2dyZXNzQ29sb3JDYWNoZSIsIk1hcCIsImdldFByb2dyZXNzQ29sb3IiLCJjb3VudCIsImdldCIsIm5vcm1hbGl6ZWRDb3VudCIsIk1hdGgiLCJtaW4iLCJjb2xvciIsInByb2dyZXNzIiwiaW50ZXJwb2xhdGVDb2xvciIsInNldCIsImNvbG9yMSIsImNvbG9yMiIsImZhY3RvciIsImhleDEiLCJyZXBsYWNlIiwiaGV4MiIsInIxIiwic3Vic3RyIiwiZzEiLCJiMSIsInIyIiwiZzIiLCJiMiIsInJvdW5kIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImdyb3VwQWdlQ2FjaGUiLCJsYXN0SGlzdG9yeUxlbmd0aCIsImNhbGN1bGF0ZUdyb3VwQWdlIiwiZ3JvdXAiLCJjbGVhciIsImdyb3VwS2V5Iiwic29ydCIsImpvaW4iLCJncm91cEFnZSIsImluY2x1ZGVzIiwiZmluZFJlcGVhdHMiLCJyZXBlYXRzIiwiaiIsInB1c2giLCJ2YWx1ZSIsInN0YXJ0IiwiZ2V0UmVwZWF0SW5kZXhlcyIsInJlcGVhdEluZGV4ZXMiLCJTZXQiLCJrIiwiYWRkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/casino/utils/rouletteUtils.ts\n"));

/***/ })

});